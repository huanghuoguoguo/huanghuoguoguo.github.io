---
layout: post
title: "miniob&ob比赛收获"
date:   2024-12-25
tags: [OceanBase, Miniob]
comments: true
author: huanghuoguoguo
---

历史两个月左右，最后取得了一个还算是过得去的结果。有进步就是好的，总比原地踏步强。

## miniob
尝试去理解执行计划，statement。从一开始的网络层接收到用户的原始输入开始，到*层，到存储引擎层，大致都做了相关的赛题。符号引用转变为直接引用。

语法分析yacc，每个赛题之间大多有联系和联动，比如null，unique等。了解了像这样的基础数据库功能的实现。虽然他只有单机，行存储，默认单线程。但是实现了事务，自定义索引，块存储器，下推，比较完备的b+树索引，同时我们还在上面实现了vector索引。同时，在初赛就有benchmark的要求，为了达成这个要求，重新审视了代码链路，将内存泄漏，不必要的拷贝，更高效的数据类型转换都实现了。

对面向对象的知识和概念，以及实践都有了更深刻的认识。同时其中有一些设计模式，也有直观的感受，工厂模式，策略模式，桥接模式等等，以及为了实现view实现了代理模式。

对数据如何存储在磁盘上有了深刻的认识。还有diskbuffer pool，等等，知道了作用。内存级别的索引。

虽然diskbuffer不需要我们维护，但是还是需要知道它的应用场景以及为什么要用，以及实现方式。

cpu或者内存管理，每次从磁盘读取一页出来，是直接取一页的，而不是指定位置上的指定长度的数据，是会有部分预取的。同时因为有局部性原理，事实证明这种预取是有效的。现在很多都会用预取来优化性能。这是预取一页，被动预取，还有主动预取，明确知道那部分数据会被读取，ob和kafka等都会实现，带有流式数据的特征的都会实现这一个点。

并且，通过lru等方式管理页，能够显著提高性能，用bitmap管理脏页空闲页，也是高效的方式。	



## OB 索引优化
性能优化和场景设计不一样，性能优化需要对调用链路上的所有代码做考量，通过火焰图等等性能工具，进行针对性调优。赛题的维度是不变的，所以针对这部分，做了最适合的simd指令优化，以及存储方式的优化。针对大limit的优化，分区堆的优化，从qps和执行耗时上体现出来，有微弱的增强。虽然和别人还是有较大的差距，但是仍然是一个非常宝贵的经历。

剪枝策略，多线程优化等。

搜寻过程中对结果做评估。SQ4，SQ8，PQ8，PQ4等优化，以代价较低的计算代替精确计算，提高速度等。

第一次对性能优化有了直观的认识，对之后自己写的接口做qps等测试有一些影响。

oceanbase是多租户，分布式的，和mysql等有很大的区别。多数的任务会经过适配层，被master分配给具体的执行器执行。比如建立索引等等。同时这还是一个类内存数据库，在使用过程中会将查询的，插入的数据，优先放入内存中。通过LSM树，分为多个SStable，提高qps。热点数据，冷热分离，存储分离。

第一次接触火焰图，反应性能的，再次之前接触过的类似的就是jvm内存分析，查看大对象。

计算存储分离：节点可以只保存元数据，然后指示存储数据的节点进行计算，减少数据的拷贝。在多分片的情况下，效率比较高。

作为java选手，不仅要对业务场景，分布式等业务上的东西要熟悉，有时候也会追求一下高性能，以及对计算机系统的了解程度。除了性能要求，还有代码可读性，设计的可扩展性等等，硬件亲和性，在这次写simd指令代码时有接触到。

每个组件在设计时，都期望和其他组件是解耦的。是独立的。如果迫不得已要有依赖，期望依赖是单向的，不能存在循环依赖。

为了高性能，学习了哪些东西？

缓存预取，提高缓存命中率。

异步操作。

多线程建堆。

把有效数据放在更快的地方。顺序读比随机读快很多，尽量使用顺序读。增量大部分情况下好于全量。

