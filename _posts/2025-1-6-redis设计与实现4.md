---
layout: post
title: "《redis设计与实现》 第四部分 独立功能的实现"
date:   2025-2-3
tags: [redis, 底层, 书籍]
comments: true
author: huanghuoguoguo
---

# 第四部分 独立功能的实现

## 第十八章 发布与订阅

p290 SUBSCRIBE命令
p290 PSUBSCRIBE命令

Redis 的发布与订阅（Pub/Sub）功能是一种消息通信模式，允许客户端订阅特定的频道或模式，从而接收由其他客户端发布的消息。这一功能在实时消息推送、聊天应用、事件通知等场景中非常有用。这一章详细介绍了 Redis 中的订阅与退订机制、消息发送以及查看订阅信息的方法。

### 18.1 频道的订阅与退订

p292 pubsub_channels字典
p293 订阅频道
p294 退订频道

Redis 提供了 `SUBSCRIBE` 和 `PSUBSCRIBE` 命令用于订阅频道和模式。

- **`SUBSCRIBE` 命令**：用于订阅一个或多个具体的频道。当客户端订阅某个频道后，该客户端会接收该频道上发布的所有消息。
- **`pubsub_channels` 字典**：服务器使用 `pubsub_channels` 字典来记录所有被订阅的频道，字典的键是频道名称，值是订阅该频道的客户端列表。
- **订阅频道**：当客户端发送 `SUBSCRIBE` 命令时，服务器会将该客户端添加到相应频道的订阅列表中。
- **退订频道**：客户端可以通过 `UNSUBSCRIBE` 命令退订一个或多个频道，服务器会将该客户端从相应频道的订阅列表中移除。

### 18.2 模式的订阅与退订

p296 订阅模式
p297 退订模式

- **`PSUBSCRIBE` 命令**：用于订阅一个或多个符合特定模式的频道。模式使用通配符 `*` 表示任意字符，例如 `news.*` 表示订阅所有以 `news.` 开头的频道。
- **订阅模式**：当客户端发送 `PSUBSCRIBE` 命令时，服务器会将该客户端添加到模式订阅列表中。
- **退订模式**：客户端可以通过 `PUNSUBSCRIBE` 命令退订一个或多个模式，服务器会将该客户端从模式订阅列表中移除。

### 18.3 发送消息

p298 将消息发送给频道订阅者
p299 将消息发送给模式订阅者

- **将消息发送给频道订阅者**：当客户端使用 `PUBLISH` 命令向某个频道发送消息时，服务器会将消息发送给所有订阅该频道的客户端。
- **将消息发送给模式订阅者**：服务器还会检查所有订阅的模式，将消息发送给订阅了与该频道匹配模式的客户端。

### 18.4 查看订阅信息

p301 PUBSUB CHANNELS
p301 PUBSUB NUMSUB
p303 PUBSUB NUMPAT

- **`PUBSUB CHANNELS` 命令**：用于查看当前被订阅的所有频道。
- **`PUBSUB NUMSUB` 命令**：用于查看每个频道的订阅者数量。
- **`PUBSUB NUMPAT` 命令**：用于查看当前订阅的模式数量以及每个模式的订阅者数量。

------

Redis 的发布与订阅功能通过 `SUBSCRIBE`、`PSUBSCRIBE`、`PUBLISH` 等命令实现了消息的订阅和发布机制。客户端可以订阅特定的频道或模式，接收由其他客户端发布的消息。服务器通过 `pubsub_channels` 字典和模式订阅列表来管理订阅信息，并将消息发送给相应的订阅者。通过 `PUBSUB` 命令，客户端可以查看当前的订阅状态，包括频道的订阅者数量和模式的订阅者数量。这些功能使得 Redis 在实时消息推送、聊天应用、事件通知等场景中具有广泛的应用价值。

## 第十九章 事务

Redis 的事务功能允许客户端将多个命令打包成一个操作序列，一次性执行这些命令，从而提供了原子性操作。事务的实现、`WATCH` 命令的机制以及事务的 ACID 特性共同构成了 Redis 事务的核心功能。这一章详细介绍了 Redis 事务的实现细节、`WATCH` 命令的实现原理，以及事务的原子性、一致性、隔离性和持久性。

### 19.1 事务的实现

p306 事务开始
p306 MULTI命令
p306 命令入队
p307 事务队列
p307 mstate属性
p309 执行事务
p309 EXEC命令

Redis 事务的实现主要通过以下步骤完成：

1. **事务开始**：客户端发送 `MULTI` 命令，标记事务的开始。
2. **命令入队**：客户端发送的所有命令会被入队到事务队列中。
3. **执行事务**：客户端发送 `EXEC` 命令，触发事务队列中所有命令的执行。

- **`MULTI` 命令**：
  - 客户端发送 `MULTI` 命令后，Redis 会记录当前客户端处于事务状态。
  - 事务状态的客户端的所有后续命令会被放入事务队列中，而不是立即执行。
- **命令入队**：
  - Redis 的事务队列是一个简单的列表，用于存储客户端发送的命令。
  - 当客户端发送 `EXEC` 命令之前，事务队列中的命令只是被存储，未被执行。
- **`EXEC` 命令**：
  - 客户端发送 `EXEC` 命令后，Redis 会依次执行事务队列中的所有命令。
  - 执行结果按顺序返回给客户端。

### 19.2 WATCH命令的实现

p311 使用WATCH命令监视数据库键
p312 监视机制的触发
p313 判断事务是否安全
p313 一个完整的WATCH事务执行过程

`WATCH` 命令用于在事务执行前监视某些键。如果在事务执行期间被监视的键被其他客户端修改，则事务将被取消。

1. **使用 `WATCH` 命令监视数据库键**：
   - 客户端通过 `WATCH` 命令监视一个或多个键，例如 `WATCH key1 key2`。
   - Redis 会将被监视的键与客户端关联起来。
2. **监视机制的触发**：
   - 当被监视的键被修改时，Redis 会记录该键的状态变化。
   - 在事务执行时，Redis 会检查被监视的键是否被修改。
3. **判断事务是否安全**：
   - 如果事务执行时发现被监视的键已被修改，则事务不会被执行，Redis 返回一个错误给客户端。
   - 如果被监视的键未被修改，则事务正常执行。

### 19.3 事务的ACID性质

p314 原子性
p315 一致性
p316 入队错误
p317 执行错误
p317 服务器停机
p318 隔离性
p318 耐久性
p319 no-append fsync-on-rewrite配置选项对耐久性的影响

Redis 事务在设计上提供了一些 ACID 特性，但并不完全支持所有 ACID 属性：

1. **原子性**：
   - 事务的原子性保证了事务中的所有命令要么全部执行成功，要么全部不执行。
   - 如果事务队列中的任何一个命令执行失败，整个事务将被中止，已执行的命令会被回滚。
2. **一致性**：
   - Redis 事务通过原子性保证了一致性。事务的执行不会导致数据库处于不一致的状态。
   - 然而，Redis 事务的一致性并不包括数据在多个客户端之间的分布式一致性。
3. **入队错误**：
   - 在事务执行期间，如果命令在入队时就存在错误（如语法错误），Redis 会立即返回错误，并拒绝入队该命令。
4. **执行错误**：
   - 如果事务队列中的命令在执行时遇到错误（如操作不存在的键），Redis 会中止事务并返回错误。
5. **服务器停机**：
   - 如果 Redis 服务器在事务执行期间意外停机，事务的完成状态将无法保证。
   - 然而，Redis 的 RDB 和 AOF 持久化机制可以在一定程度上保证数据的持久性。
6. **隔离性**：
   - Redis 事务的隔离性较弱，因为它允许其他客户端在事务执行期间修改被监视的键。
   - 通过 `WATCH` 命令，Redis 提供了一种乐观锁机制，确保事务的一致性。
7. **耐久性**：
   - Redis 事务的耐久性取决于配置的持久化机制。
   - 如果启用了 AOF 持久化，并且 `no-appendfsync-on-rewrite` 配置选项设置为 `no`，则写操作会立即同步到磁盘，保证了耐久性。



Redis 的事务功能通过 `MULTI` 和 `EXEC` 命令实现，提供了原子性操作，确保了数据库状态的一致性。`WATCH` 命令为事务提供了一种乐观锁机制，用于在事务执行前监测键的变化，确保事务的安全性。Redis 事务的 ACID 特性在一定程度上得到了保证，但受限于 Redis 的单线程模型和应用场景，某些特性（如隔离性和耐久性）需要通过合理的配置和持久化策略来增强。通过合理的使用事务，Redis 能够在高并发环境下提供可靠的批量操作支持，满足多种业务需求。

## 第二十章 Lua脚本

## 第二十一章 排序

p344 ALPHA选项

Redis 的 `SORT` 命令是一个功能强大的排序工具，可以对存储在 Redis 中的列表、集合和有序集合等数据结构进行排序。这一章详细介绍了 `SORT` 命令的实现，包括各种选项的使用和执行步骤。

### 21.1 SORT<key>命令的实现

p346 服务器执行SORT numbers命令的详细步骤

`SORT` 命令的基本用法是对指定的键进行排序。例如，`SORT numbers` 命令会对存储在 `numbers` 键中的列表进行排序。服务器执行 `SORT numbers` 命令的详细步骤包括：

1. 获取 `numbers` 键对应的值。
2. 将值转换为可以排序的格式。
3. 按照默认的排序规则（升序）对值进行排序。
4. 将排序后的结果返回给客户端。

### 21.2 ALPHA选项的实现

p348 服务器执行SORT fruits ALPHA命令的详细步骤

`ALPHA` 选项用于对字符串类型的值进行字典序排序。例如，`SORT fruits ALPHA` 命令会对存储在 `fruits` 键中的字符串列表进行字典序排序。服务器执行 `SORT fruits ALPHA` 命令的详细步骤包括：

1. 获取 `fruits` 键对应的值。
2. 将值视为字符串，并按照字典序进行排序。
3. 将排序后的结果返回给客户端。

### 21.3 ASC选项和DESC选项的实现

`ASC` 和 `DESC` 选项分别用于指定升序和降序排序。例如，`SORT numbers ASC` 命令会对 `numbers` 列表进行升序排序，而 `SORT numbers DESC` 命令会对 `numbers` 列表进行降序排序。

### 21.4 BY选项的实现

p350 服务器执行SORT fruits BY \*-price命令的详细步骤

`BY` 选项用于根据指定的外部键进行排序。例如，`SORT fruits BY *-price` 命令会根据与 `fruits` 列表中每个元素相关的 `price` 键的值进行排序。服务器执行 `SORT fruits BY *-price` 命令的详细步骤包括：

1. 获取 `fruits` 列表中的每个元素。
2. 对于每个元素，获取与之相关的 `price` 键的值。
3. 根据 `price` 键的值进行排序。
4. 将排序后的结果返回给客户端。

### 21.5 带有ALPHA选项的BY选项的实现

p352 服务器执行SORT fruits BY \*-id ALPHA命令的详细步骤

当同时使用 `BY` 和 `ALPHA` 选项时，`BY` 选项会根据指定的外部键进行排序，而 `ALPHA` 选项会确保排序是基于字典序的。例如，`SORT fruits BY *-id ALPHA` 命令会根据 `id` 键的值进行排序，并确保排序是基于字典序的。

### 21.6 LIMIT选项的实现

p354 服务器执行SORT alphabet ALPHA LIMIT 0 4命令的详细步骤

`LIMIT` 选项用于限制返回的结果数量。例如，`SORT alphabet ALPHA LIMIT 0 4` 命令会对 `alphabet` 列表进行字典序排序，并只返回前 5 个结果（索引从 0 开始，返回 0 到 4 的结果）。

### 21.7 GET选项的实现

p356 服务器执行SORT studenst ALPHA GET \*-name命令的详细步骤

`GET` 选项用于获取与排序结果相关的其他键的值。例如，`SORT students ALPHA GET *-name` 命令会对 `students` 列表进行字典序排序，并返回与每个元素相关的 `name` 键的值。

### 21.8 STORE选项的实现

p359 服务器执行SORT students ALPHA GET \*-name命令的详细步骤

`STORE` 选项用于将排序结果存储到一个新的键中。例如，`SORT students ALPHA GET *-name STORE sorted_students` 命令会对 `students` 列表进行字典序排序，获取 `name` 键的值，并将结果存储到 `sorted_students` 键中。

### 21.9 多个选项的执行顺序

p359 选项的的执行顺序
p259 一个SORT命令的执行过程可以分为以下四步

当 `SORT` 命令包含多个选项时，这些选项的执行顺序会影响最终的排序结果。一个 `SORT` 命令的执行过程可以分为以下四步：

1. **获取键的值**：获取指定键对应的值。
2. **排序**：根据指定的排序规则（如 `ASC`、`DESC`、`BY` 等）对值进行排序。
3. **获取相关键的值**：如果使用了 `GET` 选项，获取与排序结果相关的其他键的值。
4. **限制结果数量**：如果使用了 `LIMIT` 选项，限制返回的结果数量。
5. **存储结果**：如果使用了 `STORE` 选项，将排序结果存储到一个新的键中。

------

Redis 的 `SORT` 命令提供了强大的排序功能，支持多种排序选项，包括 `ALPHA`、`ASC`、`DESC`、`BY`、`LIMIT`、`GET` 和 `STORE` 等。这些选项使得 `SORT` 命令能够灵活地处理各种排序需求，从简单的数值排序到复杂的基于外部键的排序。通过合理使用这些选项，用户可以高效地对 Redis 中的数据进行排序和处理，满足各种应用场景的需求。

## 第二十二章 二进制位数组

```
面对Redis中二进制位数组的处理，我首先想到的是，这些问题肯定不是孤立存在的，它们肯定与Redis的整体设计和数据结构紧密相关。我得先从Redis的基本原理入手，去理解二进制位数组在Redis中的地位和作用。
我注意到，Redis使用字符串对象来表示位数组，这意味着我需要深入理解Redis字符串对象的工作机制。我开始思考，这个设计背后的原因是什么？为什么不直接使用位数组，而是通过字符串对象来模拟呢？我猜测，这可能与Redis对内存管理和灵活性的需求有关。
接下来，我尝试去理解GETBIT和SETBIT命令是如何实现的。我设想，这两个命令应该涉及在字符串对象中查找和修改特定位的操作。我开始思考，Redis是如何在字符串中定位和修改这些位的？我尝试通过分解问题，将字符串看作是位数组的容器，然后思考如何通过索引访问和修改位。
在尝试过程中，我犯了一个错误，我最初以为Redis直接在内存中按位操作字符串对象，但很快我意识到这在内存管理上是不现实的，因为字符串对象可能非常大，直接按位操作会非常低效。我调整了思路，开始考虑Redis可能使用了某种索引机制，或者对字符串进行了某种形式的翻译，以便能够高效地进行位操作。
我进一步探索，开始研究BITCOUNT命令。我了解到，这个命令需要统计位数组中1的数量，这可能涉及到高效的二进制位统计算法。我开始思考，Redis是如何高效地计算这些位的？我尝试了多种算法，包括遍历每个位、使用查表法，甚至考虑了使用位操作来优化计数过程。我通过联想，想到了汉明重量的概念，这让我意识到，BITCOUNT命令的实现可能与汉明重量的计算有关。
在反复尝试和思考后，我顿悟到，BITCOUNT命令的实现可能结合了多种算法，以适应不同的数据规模和应用场景。我开始实施这个想法，考虑在数据量较小时使用遍历算法，而在数据量较大时使用更高效的算法，如variable-precision SWAR算法。
最后，我思考了BITOP命令的实现。我意识到，这个命令涉及对两个或多个位数组进行按位操作，这需要Redis能够同时操作多个字符串对象。我开始思考，Redis如何确保这些操作在内存中高效执行，以及如何处理不同长度的位数组。我尝试了多种方法，包括对位数组进行长度对齐，以及使用位掩码来简化操作。
```

p362 Redis提供了SETBIT、GETBIT、BITCOUNT、BITOP四个命令用于处理二进制位数组

Redis 提供了 `SETBIT`、`GETBIT`、`BITCOUNT` 和 `BITOP` 四个命令用于处理二进制位数组（bitset）。这些命令允许对 Redis 字符串对象中的二进制位进行操作和处理。二进制位数组通常用于高效地存储和操作位级数据，例如权限管理、布隆过滤器等。

### 22.1 位数组的表示

p363 Redis使用字符串对象来表示位数组

在 Redis 中，二进制位数组是由字符串对象表示的。每个字符串对象是一个字节数组，每个字节由 8 个二进制位组成。例如，一个字符串对象 "abc" 可看作是一个由 24 个二进制位（3 字节 × 8 位）组成的位数组。

复制

```
 0   1   2   3   ...   23
(bits) a   b   c
```

### 22.2 GETBIT命令的实现

`GETBIT` 命令用于获取位数组中指定位置的位值（0 或 1）。其语法为：

```
GETBIT key offset
```

Redis 服务器执行 `GETBIT` 命令的详细步骤如下：

1. **解析参数**：
   - 确保 `key` 存在，且其类型为字符串。
   - 确保 `offset` 是一个有效的非负整数，并且小于等于字符串对象的最大可能长度（即 512MB，对应到二进制位是 4096MB × 8 = 4096000000 位）。
2. **计算字节偏移和位掩码**：
   - 计算 `offset` 对应的字节偏移：`byte_index = offset / 8`。
   - 计算 `offset` 对应的位掩码：`bit_mask = 1 << (offset % 8)`。
3. **获取字节值**：
   - 如果 `byte_index` 超过字符串对象的当前长度，则返回 0。
   - 否则，获取 `byte_index` 对应的字节值。
4. **提取位值**：
   - 将字节值与 `bit_mask` 进行按位与运算，如果结果不为 0，则返回 1；否则返回 0。

复制

```
示例：
GETBIT mykey 0 → 返回字节索引 0 的位值。
```

### 22.3 SETBIT命令的实现

p367 SETBIT命令的执行示例
p367 带扩展操作的SETBIT命令示例

`SETBIT` 命令用于设置位数组中指定位置的位值（0 或 1）。其语法为：

```
SETBIT key offset value
```

Redis 服务器执行 `SETBIT` 命令的详细步骤如下：

1. **解析参数**：
   - 确保 `key` 是字符串类型。
   - 确保 `offset` 是一个有效的非负整数。
   - 确保 `value` 是 0 或 1。
2. **扩展字符串对象（如果需要）**：
   - 如果 `offset` 超过字符串对象的当前长度，则扩展字符串对象，填充 0 字节，直到字符串对象足够容纳 `offset`。
3. **计算字节偏移和位掩码**：
   - 计算 `offset` 对应的字节偏移：`byte_index = offset / 8`。
   - 计算 `offset` 对应的位掩码：`bit_mask = 1 << (offset % 8)`。
4. **设置位值**：
   - 获取当前字节值。
   - 如果 `value` 为 1，则使用 `|` 运算设置位；如果为 0，则使用 `& ~` 运算清除位。
5. **返回旧位值**：
   - 在设置新值之前，获取并返回旧位值。

复制

```
示例：
SETBIT mykey 0 1 → 设置字节索引 0 的位值为 1。
```

### 22.4 BITCOUNT命令的实现

p370 二进制位统计算法（1）：遍历算法
p370 二进制位统计算法（2）：查表算法
p371 二进制位统计算法（3）：variable-precision SWAR算法
p372 计算汉明重量
p374 二进制位统计算法（4）：Redis的实现

`BITCOUNT` 命令用于统计位数组中 1 的数量。其语法为：

```
BITCOUNT key [start end]
```

Redis 服务器实现 `BITCOUNT` 命令时，提供了多种高效的二进制位统计算法：

#### 1. **遍历算法**

- 遍历字符串对象中的每个字节，逐位检查是否为 1，统计总数。
- 时间复杂度为 O(n)，其中 n 是字符串的长度。

#### 2. **查表算法**

- 预先构建一个包含 256 个条目的查找表，记录每个字节中 1 的数量。
- 遍历字符串对象中的每个字节，使用查找表快速累加 1 的数量。
- 时间复杂度为 O(n)，但速度比遍历算法快。

#### 3. **variable-precision SWAR 算法**

- 使用位操作和位并行计算技术，快速统计每个字节中 1 的数量。
- 通常比查表算法更快，尤其是在现代 CPU 架构上。

#### 4. **计算汉明重量**

- 汉明重量是指一个二进制数中 1 的数量。`BITCOUNT` 命令的本质是计算汉明重量。

#### Redis 的实现

- Redis 使用 `variable-precision SWAR 算法` 来实现 `BITCOUNT` 命令，以获得最佳性能。

### 22.5 BITOP命令的实现

`BITOP` 命令用于对两个或多个位数组进行按位操作，并将结果存储到一个新的键中。其语法为：

```
BITOP operation destkey key [key ...]
```

- `operation` 可以是 `AND`、`OR`、`XOR` 或 `NOT`。
- `destkey` 是结果的存储键。
- `key` 是参与操作的位数组。

Redis 服务器执行 `BITOP` 命令的详细步骤如下：

1. **解析参数**：
   - 确保所有输入键都是字符串类型。
   - 确保 `operation` 是支持的按位操作之一。
2. **确定操作的范围**：
   - 确定所有输入位数组的最短和最长长度。
3. **执行按位操作**：
   - 根据 `operation`，逐位或逐字节地执行按位操作。
   - 如果输入位数组的长度不同，Redis 会自动对齐到最长的位数组。
4. **存储结果**：
   - 将结果存储到 `destkey` 指定的字符串对象中。

复制

```
示例：
BITOP AND resultkey key1 key2 → 对 key1 和 key2 的位数组执行按位与操作，结果存储到 resultkey。
```

------

Redis 的二进制位数组功能通过 `SETBIT`、`GETBIT`、`BITCOUNT` 和 `BITOP` 命令提供了强大的位级操作能力。这些命令基于字符串对象实现，允许用户高效地存储和处理位级数据。`SETBIT` 和 `GETBIT` 命令用于单个二进制位的读写，`BITCOUNT` 命令用于统计 1 的数量，`BITOP` 命令支持复杂的按位操作。这些功能在实际应用中非常有用，尤其是在需要高效内存管理和高性能位操作的场景中。

## 第二十三章 慢查询日志

p379 SLOWLOG GET命令

Redis 的慢查询日志功能用于记录执行时间超过指定阈值的命令，帮助开发者和运维人员分析和优化性能瓶颈。慢查询日志通过 `SLOWLOG` 命令进行管理，包括查看、删除和配置慢查询日志。

### 23.1 慢查询记录的保存

慢查询日志记录了执行时间超过 `slowlog-log-slower-than` 阈值的命令。每条记录包含以下信息：

- **日志的唯一标识符**：用于区分不同的日志条目。
- **日志被创建时的 UNIX 时间戳**：记录命令执行的时间。
- **命令执行的时长**：以微秒为单位，记录命令的执行时间。
- **执行的命令**：记录实际执行的 Redis 命令及其参数。

### 23.2 慢查询日志的阅览和删除

- **阅览慢查询日志**：使用 `SLOWLOG GET` 命令获取慢查询日志。可以指定获取的条目数量，例如 `SLOWLOG GET 10` 获取最近的 10 条日志。
- **删除慢查询日志**：使用 `SLOWLOG RESET` 命令清空慢查询日志。

### 23.3 添加新日志

Redis 自动将执行时间超过 `slowlog-log-slower-than` 阈值的命令添加到慢查询日志中。阈值可以通过配置文件或 `CONFIG SET` 命令进行调整。

## 第二十四章 监视器

Redis 的监视器功能允许客户端实时监控服务器接收到的所有命令，这对于调试和分析非常有用。

### 24.1 成为监视器

客户端可以通过发送 `MONITOR` 命令成为监视器。成为监视器后，客户端会接收到来自服务器的实时命令信息。

### 24.2 向监视器发送命令信息

当服务器接收到客户端的命令请求时，会将命令信息发送给所有处于监视器状态的客户端。命令信息包括：

- **时间戳**：命令执行的时间。
- **客户端地址**：发送命令的客户端地址。
- **命令**：实际执行的 Redis 命令及其参数。
- **命令执行结果**：命令执行的结果摘要。

通过监视器，开发者可以实时观察 Redis 服务器的命令执行情况，有助于调试和性能分析。

Redis 的慢查询日志功能提供了对性能瓶颈的洞察，通过记录执行时间过长的命令，帮助开发者和运维人员优化数据库性能。监视器功能则允许实时监控服务器的命令执行情况，对于调试和分析非常有用。这些功能共同构成了 Redis 的性能分析和监控工具，使得 Redis 在高并发和大规模数据场景中更加可靠和高效。