---
layout: post
title: "《redis设计与实现》 第一部分 数据结构与对象"
date:   2025-1-25
tags: [redis, 底层, 书籍]
comments: true
author: huanghuoguoguo
---

很早之前就开始看的一本书，奈何当时才疏学浅，也缺乏实践经验，所以很多东西都忘记了或是体验不深。如果再有机会再读一次的话，我会慢慢来。

先回忆一下这本书的结构。印象中，这本书的章节安排是从 Redis 的基本概念讲起，然后逐步深入到数据结构、持久化机制、网络协议、集群架构等核心内容。每一章都围绕一个主题展开，比如数据结构那一章会详细讲解 Redis 使用的底层数据结构，比如字典、跳跃表、压缩列表等；而持久化那一章则会深入分析 RDB 和 AOF 的实现原理和优缺点。

有些内容也还在才疏学浅的状态，不能做一个很深入的剖析。

# 第一部分 数据结构与对象

## 第二章 简单动态字符串

第一章是“字符串对象的实现”，这一章主要讲解 Redis 中字符串对象的底层实现。我记得这一章提到了 Redis 的对象系统，以及字符串对象在不同场景下的存储方式，比如整数和字符串。这里的核心知识点应该是 Redis 对象的多态性，以及字符串对象的编码方式（int、embstr、raw）。可以思考的问题是：为什么 Redis 要设计一个对象系统？这种设计有什么好处？另外，字符串对象的编码方式是怎么选择的？这种选择对性能有什么影响？

p8 简单动态字符串SDS

### 2.1 SDS的定义

p9 每个sds.h/sdshdr结构表示一个SDS值

### 2.2 SDS与C字符串的区别

p10 常数复杂度获取字符串长度
p10 获取一个SDS长度的复杂度仅为O(1)
p11 杜绝缓冲区溢出
p11 SDS修改操作
p12 减少修改字符串带来的内存重分配次数
p13 空间预分配
p14 惰性空间释放
p15 二进制安全
p16 SDS的二进制安全
p16 兼容部分C字符串函数
p17 SDS可以在有需要时重用<String.h>函数库
p17 总结
p17 C字符串和SDS之间的区别

------

在C语言中，字符串是通过以空字符`\0`结尾的字符数组来表示的。获取C字符串的长度需要遍历整个字符串直到遇到`\0`字符，这意味着获取长度的时间复杂度为O(n)。此外，C字符串在进行修改操作时，如追加或截断，很容易引发缓冲区溢出问题，因为C字符串操作函数通常不会检查目标缓冲区的大小是否足够。为了修改字符串，开发者往往需要手动管理内存分配和释放，这不仅容易出错，而且在频繁修改字符串时，频繁的内存分配和释放也会导致性能下降。

相比之下，SDS是Redis中自定义的一种动态字符串实现，它通过在数据结构中显式存储字符串的长度信息，使得获取字符串长度的操作时间复杂度仅为O(1)，极大地提高了效率。SDS在设计上杜绝了缓冲区溢出的问题。当对SDS进行修改操作时，它会自动检查空间是否足够，并在必要时自动进行内存分配，从而避免了因空间不足而导致的缓冲区溢出问题。同时，SDS通过空间预分配和惰性空间释放机制，减少了修改字符串时的内存重分配次数。具体来说，在字符串增长时，SDS会根据当前长度动态分配额外的空间，以减少后续的内存分配次数；而在字符串缩短时，SDS不会立即释放多余的空间，而是保留这些空间以供后续使用，从而进一步优化了性能。

此外，SDS还具有二进制安全的特性，这意味着它可以存储任意的二进制数据，而不仅仅是可打印的字符。这一点对于Redis这种需要处理各种类型数据的应用来说非常重要。尽管SDS提供了自己的字符串操作函数，但它也兼容部分C字符串函数，并且在需要时可以重用`<string.h>`函数库中的函数，这使得SDS在保持自身优势的同时，也能够方便地与现有的C语言字符串操作进行集成。

**总结**：SDS与C字符串之间的主要区别在于，SDS通过在数据结构中存储长度信息，实现了常数复杂度获取字符串长度；通过自动检查空间和管理内存分配，杜绝了缓冲区溢出问题；通过空间预分配和惰性空间释放机制，减少了内存重分配次数，提高了性能；并且具有二进制安全的特性，能够存储任意二进制数据。同时，SDS还兼容部分C字符串函数，可以在需要时重用`<string.h>`函数库，这使得SDS在保持自身优势的同时，也能够方便地与现有的C语言字符串操作进行集成。这些特性使得SDS在Redis中成为一种更加高效、安全且灵活的字符串处理方式。

### 2.3 SDS API

P17 SDS的主要操作API

### 2.4 重点回顾

p18 SDS相比C字符串的优点

这一章主要讲解 Redis 中列表对象的底层实现。我记得这一章提到了两种数据结构：压缩列表和双向链表。压缩列表在元素较少时使用，而双向链表在元素较多时使用。这里的核心知识点应该是 Redis 如何根据列表的大小和元素类型选择合适的数据结构。在阅读这一章时，可以思考的问题是：为什么 Redis 要为列表对象设计两种不同的底层实现？这种设计有什么优缺点？另外，Redis 是如何判断应该使用哪种实现的？这种判断机制是怎么实现的？

Redis 为列表对象设计了两种底层实现——压缩列表（ZipList）和双向链表（LinkedList），这种设计主要是为了在不同的使用场景下平衡性能和内存使用。

当列表元素数量较少且每个元素的大小较小时，Redis 会使用压缩列表作为底层实现。压缩列表是一种内存连续的紧凑数据结构，能够高效地存储小数据量的列表，节省内存空间。例如，当列表对象保存的所有字符串元素的长度都小于64字节，并且元素数量小于512个时，Redis 会选择使用压缩列表。这种设计的优点在于内存使用效率高，适合存储小型配置项、用户偏好设置或小型缓存等。

然而，当列表元素数量较多，或者存在长度超过64字节的字符串时，Redis 会切换到底层实现为双向链表。双向链表允许在O(1)时间复杂度内完成在列表头部或尾部的元素插入和删除操作，适合存储大量元素或者需要频繁进行头尾插入和删除操作的场景。这种设计的缺点是内存使用相对较高，因为每个节点都需要额外的指针来存储前驱和后继节点。

Redis 通过一系列的判断机制来决定使用哪种底层实现。具体来说，当列表的元素数量超过一定阈值（如512个），或者存在长度超过64字节的元素时，Redis 会将底层实现从压缩列表切换为双向链表。这种判断机制是自动的，无需用户手动干预，从而确保了在不同的使用场景下都能选择最合适的数据结构。

这种设计的优缺点显而易见。优点是能够根据列表的大小和元素类型动态选择最适合的底层实现，从而在内存使用和操作性能之间取得平衡。缺点是当列表在两种实现之间切换时，可能会涉及到一定的内存重新分配和数据迁移开销。不过，这种开销在大多数情况下是可以接受的，因为它能够显著提升系统的整体性能和资源利用效率。

## 第三章 链表

### 3.1 链表和链表节点的实现

p20 list结构
p21 Redis链表的实现特性

### 3.2 链表和链表节点的API

p21 用于操作链表和链表节点的API

### 3.3 重点回顾

在 Redis 的实现中，链表是一种重要的基础数据结构，广泛应用于多种功能模块中。链表由多个节点组成，每个节点包含指向其前驱和后继节点的指针，形成一个双向链表结构。这种设计使得链表在插入和删除节点时具有高效的性能，尤其是在链表的头部和尾部进行操作时，时间复杂度仅为 O(1)。

在 3.1 节中，书中首先介绍了 Redis 中链表的结构定义。链表由一个 `list` 结构体表示，其中包含指向链表头部和尾部节点的指针，以及记录链表节点总数的字段。每个链表节点由一个 `listNode` 结构体表示，包含指向其前驱和后继节点的指针，以及存储实际数据的指针。这种结构使得链表能够灵活地存储不同类型的数据，并且支持高效的双向遍历。

接着，书中探讨了 Redis 链表的实现特性。Redis 的链表设计具有高度的灵活性和安全性。例如，链表的节点可以存储任意类型的数据，这使得链表能够适应多种不同的应用场景。此外，链表的实现还考虑到了线程安全问题，通过适当的锁机制确保了在多线程环境下的正确性。这些特性使得 Redis 的链表不仅能够高效地支持各种操作，还能在复杂的运行环境中保持稳定。

在 3.2 节中，书中详细介绍了用于操作链表和链表节点的 API。这些 API 提供了丰富的功能，包括创建和销毁链表、插入和删除节点、遍历链表等。通过这些 API，开发者可以方便地对链表进行各种操作，而无需直接处理底层的链表结构。例如，`listAddNodeHead` 和 `listAddNodeTail` 函数分别用于在链表头部和尾部插入节点，而 `listDelNode` 函数则用于删除指定节点。这些 API 的设计使得链表的操作变得简单直观，同时也保证了操作的效率和安全性。

在 3.3 节中，书中对链表的实现及其 API 进行了重点回顾。Redis 的链表通过 `list` 和 `listNode` 结构体实现，支持高效的插入、删除和遍历操作。链表的实现特性包括对任意类型数据的支持和线程安全机制，使其能够适应多种应用场景。通过提供的 API，开发者可以方便地对链表进行操作，而无需深入了解底层实现细节。这些内容构成了 Redis 中链表的核心知识，为后续章节中对 Redis 数据结构和功能的深入理解奠定了基础。

## 第四章 字典

### 4.1 字典的实现

p24 哈希表

p24 dictht结构
p25 哈希表节点

p25 dictEntry结构
p26 字典

p26 dic结构

在 Redis 中，字典是一种非常重要的数据结构，用于存储键值对。字典的底层实现基于哈希表，而哈希表的核心是一个数组，数组的每个槽位可以存储一个或多个键值对。具体来说，Redis 的哈希表由 `dictht` 结构体表示，它包含一个数组 `table`，数组的每个槽位指向一个链表的头节点，链表中的每个节点是一个 `dictEntry` 结构体，存储了键值对以及指向下一个节点的指针。字典本身由 `dict` 结构体表示，它包含两个哈希表（用于渐进式 rehash）以及其他元数据，如当前键值对的数量和负载因子等。

### 4.2 哈希算法

p27 Redis计算哈希值和索引值的方法
p28 Redis使用MurmurHash2算法计算键的哈希值
Redis 使用哈希算法将键映射到哈希表的槽位中。具体来说，Redis 使用 MurmurHash2 算法计算键的哈希值，然后通过哈希值和哈希表的大小进行取模运算，得到键在哈希表中的索引值。MurmurHash2 是一种高效的哈希算法，能够快速生成均匀分布的哈希值，从而减少键冲突的概率。

### 4.3 解决键冲突

p28 Redis的哈希表使用链地址法解决键冲突

在哈希表中，不同的键可能会被映射到同一个槽位，这种情况称为键冲突。Redis 的哈希表使用链地址法来解决键冲突。具体来说，当多个键被映射到同一个槽位时，这些键值对会被存储在同一个链表中。通过链表的方式，Redis 能够有效地解决键冲突问题，同时保证了哈希表的高效性。

### 4.4 rehash

p29 Redis对字典的哈希表执行rehash的步骤如下
p32 哈希表的扩展与收缩
p32 负载因子

随着字典中键值对数量的增加或减少，哈希表的负载因子（键值对数量与哈希表大小的比值）会发生变化。当负载因子超过一定阈值时，Redis 会对哈希表进行 rehash 操作，以扩展或收缩哈希表的大小。rehash 的目的是保持哈希表的性能，避免因负载因子过高而导致查找效率下降。具体步骤包括创建一个新的哈希表，将原哈希表中的键值对重新映射到新哈希表中，并在完成后释放原哈希表。

### 4.5 渐进式rehash

p33 渐进式rehash详细步骤
p36 渐进式rehash执行期间的哈希表操作

为了减少 rehash 操作对性能的影响，Redis 采用了渐进式 rehash 的机制。在渐进式 rehash 过程中，Redis 不会在短时间内完成整个 rehash 操作，而是将 rehash 分解为多个小步骤，逐步将原哈希表中的键值对迁移到新哈希表中。这样可以避免一次性 rehash 带来的性能开销，同时保证了字典操作的高效性。在渐进式 rehash 执行期间，字典的查找、插入和删除操作会同时在两个哈希表上进行，直到所有键值对都迁移到新哈希表中为止。

### 4.6 字典API

p36 字典的主要操作API

Redis 提供了一系列的字典操作 API，用于实现对字典的增、删、改、查等操作。这些 API 包括创建和销毁字典、插入和删除键值对、查找键值对等。通过这些 API，开发者可以方便地使用字典来存储和管理键值对数据，而无需直接操作底层的哈希表结构。

Redis 的字典是一种基于哈希表实现的高效键值对存储结构。字典的底层实现包括 `dictht` 结构体（哈希表）、`dictEntry` 结构体（哈希表节点）和 `dict` 结构体（字典）。Redis 使用 MurmurHash2 算法计算键的哈希值，并通过链地址法解决键冲突问题。为了保持哈希表的性能，Redis 在负载因子超过一定阈值时会执行 rehash 操作，通过渐进式 rehash 机制将 rehash 分解为多个小步骤，避免一次性操作带来的性能开销。Redis 还提供了一系列字典操作 API，使得开发者可以方便地对字典进行各种操作。这些设计使得 Redis 的字典在高效性和灵活性之间取得了良好的平衡，成为 Redis 中一个非常重要的基础数据结构。

### 第五章 跳跃表

p38 跳跃表

Redis 中的跳跃表是一种高效的数据结构，主要用于实现有序集合（Sorted Set）功能。跳跃表通过多层索引的方式，能够在平均时间复杂度为 *O*(log*n*) 的情况下完成插入、删除和查找操作。这种数据结构结合了链表和二叉搜索树的优点，既支持快速查找，又能够动态扩展。

### 5.1 跳跃表的实现

p39 跳跃表由zskiplistNode和zskiplist两个结构定义

p39 zskiplist结构

p40 跳跃表节点

p40 zskiplistNode结构
p40 层
p40 前进指针
p41 跨度
p42 后退指针
p42 分值和成员
p43 跳跃表

跳跃表的实现基于两个核心结构：`zskiplistNode` 和 `zskiplist`。`zskiplistNode` 表示跳跃表中的节点，每个节点存储一个元素的值（分值）和一个指向该元素的指针（成员）。节点还包含多个层（level），每层包含一个前进指针，用于快速跳过多个节点。每个前进指针还记录了跨度（span），表示从当前节点到下一个节点之间的节点数。此外，每个节点还包含一个后退指针，用于从后向前遍历跳跃表。`zskiplist` 结构则表示整个跳跃表，包含指向头节点和尾节点的指针，以及跳跃表的当前长度等信息。

### 5.2 跳跃表API

p44 跳跃表的所有操作API

Redis 提供了一系列的跳跃表操作 API，用于实现对跳跃表的插入、删除、查找等操作。这些 API 包括创建和销毁跳跃表、插入新节点、删除节点、查找节点等。通过这些 API，开发者可以方便地使用跳跃表来存储和管理有序数据，而无需直接操作底层的跳跃表结构。这些操作的实现利用了跳跃表的多层索引特性，确保了高效性。



Redis 的跳跃表是一种高效的有序数据结构，通过多层索引的方式实现了快速的插入、删除和查找操作。跳跃表的实现基于 `zskiplistNode` 和 `zskiplist` 两个结构，其中 `zskiplistNode` 表示节点，包含分值、成员、前进指针、跨度和后退指针等信息，而 `zskiplist` 表示整个跳跃表，包含头尾节点指针和长度等信息。Redis 提供了一系列的跳跃表操作 API，使得开发者可以方便地对跳跃表进行各种操作，而无需直接处理底层实现细节。这些设计使得跳跃表在 Redis 中成为一种非常重要的基础数据结构，特别是在实现有序集合功能时发挥了关键作用。

## 第六章 整数集合

Redis 中的整数集合（IntSet）是一种用于存储整数值的集合数据结构，它通过紧凑的数组实现，具有高效的空间利用率和快速的查找性能。整数集合的设计目标是为 Redis 的集合操作提供一种高效的底层实现，尤其是在处理整数数据时。

### 6.1 整数集合的实现

p47 contents数组（整数集合底层实现）的真正类型取决于encoding的值

整数集合的底层实现基于一个动态数组 `contents`，该数组用于存储集合中的整数值。数组的类型取决于 `encoding` 字段的值，`encoding` 可以是 `INTSET_ENC_INT16`、`INTSET_ENC_INT32` 或 `INTSET_ENC_INT64`，分别表示数组中的整数以 16 位、32 位或 64 位整数的形式存储。这种设计使得整数集合能够根据存储的整数范围动态选择最合适的存储类型，从而节省内存。

### 6.2 升级

p48 升级整数集合并添加新元素的三步骤
p50 升级之后新元素的摆放位置

当尝试向整数集合中添加一个超出当前编码范围的整数时，整数集合会进行升级操作。升级过程包括以下三个步骤：

1. **分配新的内存空间**：根据新的整数范围，分配一个更大容量的数组，并将所有现有元素复制到新数组中。
2. **更新编码字段**：将 `encoding` 字段更新为新的编码值，以反映新的整数范围。
3. **插入新元素**：将新元素插入到新数组的正确位置，并保持数组的有序性。

升级后，新元素会被插入到数组的适当位置，以确保整数集合仍然保持有序。这种有序性使得整数集合能够快速进行查找和删除操作。

### 6.3 升级的好处

p50 提升灵活性
p50 节约内存

升级操作虽然会带来一定的性能开销，但它也带来了显著的好处：

- **提升灵活性**：整数集合能够根据存储的整数范围动态调整存储类型，从而支持更广泛的整数范围。
- **节约内存**：通过选择最合适的存储类型，整数集合能够高效地利用内存，避免不必要的空间浪费。

### 6.4 降级

与升级相对，降级操作是指当整数集合中的所有元素都小于当前编码范围时，可以将整数集合降级到更小的编码类型，从而进一步节省内存。然而，Redis 的整数集合实现中并没有直接提供降级操作，因为升级操作已经足够灵活地处理了大部分场景。

### 6.5 整数集合API

p51 整数集合的操作API

Redis 提供了一组操作整数集合的 API，用于实现对整数集合的增、删、查等操作。这些 API 包括：

- **创建和销毁整数集合**：用于初始化和释放整数集合的内存。
- **添加元素**：向整数集合中插入一个新元素，如果需要，会自动进行升级操作。
- **删除元素**：从整数集合中移除一个元素。
- **查找元素**：检查一个元素是否存在于整数集合中。
- **获取集合大小**：返回整数集合中元素的数量。

这些 API 的设计使得开发者可以方便地使用整数集合来存储和管理整数数据，而无需直接处理底层的数组和编码逻辑。



Redis 的整数集合是一种高效的数据结构，用于存储整数值。它通过动态数组实现，根据存储的整数范围动态选择最合适的存储类型（16 位、32 位或 64 位整数），从而节省内存并提升灵活性。当需要插入超出当前编码范围的整数时，整数集合会进行升级操作，通过分配新的内存空间、更新编码字段和插入新元素来支持更大的整数范围。虽然 Redis 没有直接提供降级操作，但升级机制已经足够灵活地处理大部分场景。Redis 提供了一系列整数集合操作 API，使得开发者可以方便地对整数集合进行各种操作，而无需直接处理底层实现细节。这些设计使得整数集合在 Redis 中成为一种非常重要的基础数据结构，特别是在实现集合操作时发挥了关键作用。

## 第七章 压缩链表

p52 压缩链表概念

压缩链表（ZipList）是 Redis 中一种高效的数据结构，用于实现列表和哈希等数据类型。它通过紧凑的内存布局和灵活的编码方式，实现了高效的空间利用率和快速的访问性能。

### 7.1 压缩链表的构成

p53 压缩链表组成部分详细说明

压缩链表是一种内存连续的数据结构，由多个节点组成。每个节点存储一个键值对或一个值，节点之间通过指针连接。压缩链表的头部包含一些元数据，如链表的长度、内存大小等。这种结构使得压缩链表在存储小数据量时非常高效，能够节省内存空间。压缩链表的设计目标是为 Redis 的列表和哈希数据类型提供一种高效的底层实现，尤其是在数据量较小时。

### 7.2 压缩链表节点的构成

p54 previous_entry_length
p55 压缩链表从表尾节点向表头结点进行遍历的完整过程
p55 encoding
p56 content

每个压缩链表节点由以下几个部分组成：

- **previous_entry_length**：表示前一个节点的长度，用于从表尾向表头遍历时能够快速定位到前一个节点。这个字段的长度可以是 1 字节或 5 字节，具体取决于前一个节点的长度。
- **encoding**：表示当前节点数据的编码方式，决定了数据的存储格式。编码方式可以是整数（int16、int32、int64）、压缩字符串（LZF 压缩）或未压缩的字符串。
- **content**：存储实际的数据内容，其长度和格式由 `encoding` 字段决定。

从表尾节点向表头节点遍历时，通过 `previous_entry_length` 字段可以快速找到前一个节点的起始位置。这种设计使得压缩链表支持双向遍历，尽管从表尾向表头的遍历效率略低于从表头向表尾的遍历。

### 7.3 连锁更新

p58 连锁更新

在压缩链表中，当对某个节点进行修改（如插入或删除节点）时，可能需要更新多个节点的 `previous_entry_length` 字段。这种更新操作称为“连锁更新”。例如，当插入一个新节点时，新节点之后的所有节点的 `previous_entry_length` 字段都需要更新，以反映新节点的长度。同样，删除节点时也需要更新后续节点的 `previous_entry_length` 字段。连锁更新是压缩链表维护内存连续性和节点间关系的重要机制，但可能会带来一定的性能开销。

### 7.4 压缩链表 API

Redis 提供了一系列压缩链表操作 API，用于实现对压缩链表的增、删、查等操作。这些 API 包括：

- **创建和销毁压缩链表**：用于初始化和释放压缩链表的内存。
- **插入节点**：在压缩链表的指定位置插入一个新节点。
- **删除节点**：从压缩链表中移除一个节点。
- **查找节点**：根据键值查找节点。
- **获取链表长度**：返回压缩链表中节点的数量。

这些 API 的设计使得开发者可以方便地使用压缩链表来存储和管理数据，而无需直接处理底层的内存布局和节点结构。

### 

Redis 的压缩链表是一种高效的数据结构，用于实现列表和哈希等数据类型。它通过紧凑的内存布局和灵活的编码方式，实现了高效的空间利用率和快速的访问性能。压缩链表由多个节点组成，每个节点包含 `previous_entry_length`、`encoding` 和 `content` 三个部分，支持从表头到表尾以及从表尾到表头的双向遍历。当对节点进行修改时，可能需要进行连锁更新，以维护节点间的关系。Redis 提供了一系列压缩链表操作 API，使得开发者可以方便地对压缩链表进行各种操作，而无需直接处理底层实现细节。这种设计使得压缩链表在 Redis 中成为一种非常重要的基础数据结构，特别是在处理小数据量时发挥了关键作用。

## 第八章 对象

Redis 的对象系统是其数据存储和操作的核心机制。通过对象的类型和编码，Redis 能够高效地处理各种数据结构，并根据数据的特点动态选择最优的存储方式。

### 8.1 对象的类型与编码

p61 redisObject结构
p61 类型
p61 对象的类型
p61 TYPE命令
p62 编码和底层实现
p62 encoding属性记录了对象所使用的编码
p62 每种类型的对象可以使用的编码
p63 OBJECT ENCODING命令

Redis 使用 `redisObject` 结构来表示对象，其中包含对象的类型（`type`）和编码（`encoding`）属性。对象的类型决定了对象的行为和可执行的命令，而编码则记录了对象底层的具体实现方式。每种类型的对象可以使用不同的编码方式，以优化内存使用和操作性能。例如，字符串对象可以使用 `int`、`raw` 或 `embstr` 编码，而列表对象可以使用 `ziplist` 或 `linkedlist` 编码。Redis 提供了 `TYPE` 和 `OBJECT ENCODING` 命令，分别用于查询对象的类型和编码方式。

### 8.2 字符串对象

p64 字符串对象的编码可以是int、raw或者embstr
p65 embstr编码的字符串对象来保存短字符串值的好处
p66 字符串对象保存各类型值得编码方式
p66 编码的转换
p67 字符串命令的实现

字符串对象是 Redis 中最基本的数据类型，其编码可以是 `int`（用于存储小整数）、`raw`（用于存储任意字符串）或 `embstr`（用于存储短字符串）。`embstr` 编码的字符串对象通过将字符串值直接嵌入对象结构中，节省了内存空间，特别适合存储短字符串值。字符串对象的编码方式会根据存储的值动态转换，例如，当一个整数值被存储为字符串时，可能会使用 `int` 编码，而当字符串值被修改为非整数时，编码会转换为 `raw`。Redis 的字符串命令（如 `SET`、`GET`）通过操作字符串对象来实现。

### 8.3 列表对象

p68 列表对象的编码可以是ziplist或者Linkedlist
p70 编码转换
p70 列表对象使用ziplist编码的两个条件

列表对象的编码可以是 `ziplist` 或 `linkedlist`。`ziplist` 编码的列表对象使用压缩链表实现，适用于存储较短的列表，能够节省内存。当列表元素较多或元素值较大时，Redis 会将列表对象的编码从 `ziplist` 转换为 `linkedlist`，以提高操作性能。`linkedlist` 编码的列表对象使用双向链表实现，支持高效的插入和删除操作。列表对象的编码转换基于两个条件：列表元素的数量和元素值的大小。

### 8.4 哈希对象

p71 哈希对象的编码可以是ziplist或者hashtable
p73 编码转换
p73 哈希对象使用ziplist编码的两个条件
p74 哈希命令的实现

哈希对象的编码可以是 `ziplist` 或 `hashtable`。`ziplist` 编码的哈希对象使用压缩链表实现，适用于存储较小的哈希表，能够节省内存。当哈希表的大小超过一定阈值时，Redis 会将哈希对象的编码从 `ziplist` 转换为 `hashtable`，以提高操作性能。`hashtable` 编码的哈希对象使用哈希表实现，支持高效的查找、插入和删除操作。哈希对象的编码转换基于两个条件：哈希表中键值对的数量和键值对的大小。

### 8.5 集合对象

p75 集合对象的编码可以是intset或者hashtable
p75 编码的转换
p75 集合对象使用intset编码的两个条件
p76 集合命令的实现

集合对象的编码可以是 `intset` 或 `hashtable`。`intset` 编码的集合对象使用整数集合实现，适用于存储整数值的集合，能够节省内存并提供高效的查找性能。当集合中包含非整数值或集合大小超过一定阈值时，Redis 会将集合对象的编码从 `intset` 转换为 `hashtable`。`hashtable` 编码的集合对象使用哈希表实现，支持高效的查找、插入和删除操作。集合对象的编码转换基于两个条件：集合中元素的数量和元素的类型。

### 8.6 有序集合对象

p77 有序集合对象的编码可以是ziplist或者skiplist
p78 为什么有序集合需要同时使用跳跃表和字典来实现
p79 编码的转换
p79 有序集合对象使用ziplist编码的两个条件
p80 有序集合命令的实现

有序集合对象的编码可以是 `ziplist` 或 `skiplist`。`ziplist` 编码的有序集合对象使用压缩链表实现，适用于存储较短的有序集合，能够节省内存。当有序集合的大小超过一定阈值时，Redis 会将有序集合对象的编码从 `ziplist` 转换为 `skiplist`，以提高操作性能。`skiplist` 编码的有序集合对象使用跳跃表实现，支持高效的查找、插入和删除操作。有序集合对象的编码转换基于两个条件：有序集合中元素的数量和元素值的大小。有序集合需要同时使用跳跃表和字典来实现，以支持快速的范围查询和成员查找。

### 8.7 类型检查与命令多态

p82 类型检查的实现
p83 类型检查过程
p83 多态命令的实现
p83 一些命令是多态的

Redis 在执行命令时会进行类型检查，确保命令与对象的类型匹配。类型检查的实现基于对象的 `type` 属性，通过检查对象的类型来决定是否允许执行特定的命令。此外，Redis 的一些命令是多态的，即它们可以作用于多种类型的对象。例如，`DEL` 命令可以删除任意类型的对象，而 `EXISTS` 命令可以检查任意类型的对象是否存在。

### 8.8 内存回收

p84 Redis使用引用计数法实现内存回收机制
p84 引用计数规则

Redis 使用引用计数法实现内存回收机制。每个对象都有一个引用计数器，记录指向该对象的指针数量。当引用计数器为零时，对象占用的内存会被自动释放。引用计数规则确保了内存的高效管理和对象的生命周期管理。

### 8.9 对象共享

p85 让多个键共享同一个值对象需要执行两个步骤
p86 Redis在初始化服务器时创建了一万个字符串对象，包含0到9999的所有整数值，并将它们作为共享对象
p86 OBJECT REFCOUNT命令
p87 为什么Redis不共享包含字符串的对象

Redis 允许多个键共享同一个值对象，以节省内存。共享对象的实现需要执行两个步骤：首先，将多个键指向同一个值对象；其次，确保在修改值对象时不会影响其他共享该对象的键。Redis 在初始化服务器时创建了一万个字符串对象，包含从 0 到 9999 的所有整数值，并将它们作为共享对象。通过 `OBJECT REFCOUNT` 命令可以查询对象的引用计数。Redis 不共享包含字符串的对象，因为字符串值的修改可能会导致不可预见的副作用。

### 8.10 对象的空转时长

p87 OBJECT IDLETIME命令

Redis 提供了 `OBJECT IDLETIME` 命令，用于查询对象的空转时长，即对象最后一次被访问以来经过的时间。空转时长可以用于实现内存回收策略，例如，当对象的空转时长超过一定阈值时，可以将其从内存中移除。



Redis 的对象系统通过类型和编码机制，为各种数据结构提供了高效、灵活的存储和操作方式。每种类型的对象可以根据数据的特点动态选择最优的编码方式，以优化内存使用和操作性能。字符串对象使用 `int`、`raw` 或 `embstr` 编码；列表对象使用 `ziplist` 或 `linkedlist` 编码；哈希对象使用 `ziplist` 或 `hashtable` 编码；集合对象使用 `intset` 或 `hashtable` 编码；有序集合对象使用 `ziplist` 或 `skiplist` 编码。Redis 的命令通过类型检查和多态机制实现，确保了命令的正确性和灵活性。内存回收通过引用计数法实现，对象共享机制进一步节省了内存。空转时长的管理为内存回收策略提供了支持。这些设计使得 Redis 的对象系统在高效性和灵活性之间取得了良好的平衡，成为 Redis 中一个非常重要的基础架构。



## 总结

Redis 的数据结构与对象是 Redis 设计的核心，它们为 Redis 提供了高效的数据存储和操作能力，是 Redis 高性能和灵活性的基石。这一部分详细介绍了 Redis 中的各种数据结构（如字符串、列表、哈希、集合、有序集合等）以及它们的底层实现和操作机制。通过对这些数据结构和对象的深入理解，我们可以更好地利用 Redis 的功能，优化性能，并与其他模块（如持久化、网络通信等）协同工作。

------

### 数据结构与对象的作用

Redis 的数据结构与对象是其高性能和灵活性的核心基础。这一部分详细介绍了 Redis 中的多种数据结构（如字符串、列表、哈希、集合、有序集合等）及其底层实现机制，包括灵活的编码方式、内存管理、命令多态等特性。这些设计不仅优化了内存使用和操作性能，还为 Redis 的其他模块（如持久化、网络通信等）提供了高效的支持。

#### 数据结构与对象的作用

Redis 的数据结构设计旨在高效存储和快速操作数据，以满足不同场景的需求。例如，字符串对象通过多种编码方式（如 `int`、`raw`、`embstr`）动态优化内存占用；列表对象在元素较少时使用紧凑的 `ziplist`，在元素较多时切换到高效的 `linkedlist`；哈希、集合和有序集合也通过类似的编码转换机制，在内存使用和操作性能之间取得平衡。这种灵活性使得 Redis 能够在处理小数据量时节省内存，同时在大数据量时保持高效操作。

#### 在 Redis 中的作用

这些数据结构不仅是 Redis 核心功能的基础，还与 Redis 的其他模块紧密协同。例如，高效的内存管理机制（如引用计数和对象共享）确保了内存的高效利用，避免了不必要的内存占用。命令多态和类型检查机制使得 Redis 的命令系统既严格又灵活，能够适应不同的应用场景。此外，空转时长管理（通过 `OBJECT IDLETIME` 命令）进一步优化了内存使用，避免了长时间未使用的对象占用宝贵的内存资源。

#### 作为 Redis 高性能的基石

Redis 的数据结构与对象设计是其高性能的基石。通过高效的数据结构实现、灵活的编码机制、动态内存管理以及命令多态等特性，Redis 在处理高并发请求和大规模数据时能够保持高性能和高效率。这些设计使得 Redis 在不同的应用场景下都能表现出色，成为现代应用中不可或缺的高性能键值存储系统。

总之，Redis 的数据结构与对象不仅为 Redis 的核心功能提供了坚实的基础，还通过与其他模块的协同工作，优化了整体性能和资源利用效率。这一部分的内容是理解 Redis 高性能和灵活性的关键。