---
layout: post
title: "四个gc垃圾回收器"
date:   2025-1-17
tags: [java, jvm, 底层]
comments: true
author: huanghuoguoguo
---

串行的，并行的，增量的，全量的。平行的好于串行的，增量的好于全量的，G1和ZGC就是这样的。

![](https://cdn.nlark.com/yuque/0/2024/png/32754462/1726037531891-455b41e3-06e6-435c-a0da-951c335a4df8.png)

+ <font style="color:rgb(1, 1, 1);">Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；</font>
+ <font style="color:rgb(1, 1, 1);">ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；</font>
+ <font style="color:rgb(1, 1, 1);">Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；</font>
+ <font style="color:rgb(1, 1, 1);">Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本；</font>
+ <font style="color:rgb(1, 1, 1);">Parallel Old收集器 (标记-整理算法)：老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；</font>

<font style="color:rgb(1, 1, 1);">重点掌握以下四种。</font>

<font style="color:rgb(6, 6, 7);">● </font>**<font style="color:rgb(6, 6, 7);">ZGC（Z Garbage Collector）收集器</font>**<font style="color:rgb(6, 6, 7);">： - </font>**<font style="color:rgb(6, 6, 7);">算法</font>**<font style="color:rgb(6, 6, 7);">：基于标记-整理算法，同时结合了读屏障、染色指针等技术。 - </font>**<font style="color:rgb(6, 6, 7);">特点</font>**<font style="color:rgb(6, 6, 7);">： - </font>**<font style="color:rgb(6, 6, 7);">低延迟</font>**<font style="color:rgb(6, 6, 7);">：目标是将垃圾回收导致的停顿时间控制在10毫秒以下，适合对延迟要求极高的实时系统和交互式应用。 - </font>**<font style="color:rgb(6, 6, 7);">大内存支持</font>**<font style="color:rgb(6, 6, 7);">：能高效管理TB级别的内存，适用于超大内存场景。 - </font>**<font style="color:rgb(6, 6, 7);">并发性高</font>**<font style="color:rgb(6, 6, 7);">：几乎所有操作都与应用程序线程并发执行，减少了对应用程序的影响。 - </font>**<font style="color:rgb(6, 6, 7);">收集阶段</font>**<font style="color:rgb(6, 6, 7);">： - </font>**<font style="color:rgb(6, 6, 7);">并发标记</font>**<font style="color:rgb(6, 6, 7);">：标记存活对象，此阶段与应用程序线程并发执行。 - </font>**<font style="color:rgb(6, 6, 7);">并发清理</font>**<font style="color:rgb(6, 6, 7);">：清理垃圾对象，同样与应用程序线程并发进行。 - </font>**<font style="color:rgb(6, 6, 7);">并发重定位</font>**<font style="color:rgb(6, 6, 7);">：移动存活对象，减少内存碎片，也是并发执行。</font>

<font style="color:rgb(6, 6, 7);">● </font>**<font style="color:rgb(6, 6, 7);">Shenandoah收集器</font>**<font style="color:rgb(6, 6, 7);">： - </font>**<font style="color:rgb(6, 6, 7);">算法</font>**<font style="color:rgb(6, 6, 7);">：基于标记-整理算法，采用读屏障技术</font><font style="color:rgb(6, 6, 7);">。 - </font>**<font style="color:rgb(6, 6, 7);">特点</font>**<font style="color:rgb(6, 6, 7);">： - </font>**<font style="color:rgb(6, 6, 7);">低延迟</font>**<font style="color:rgb(6, 6, 7);">：追求低延迟，与ZGC收集器类似，能有效减少垃圾回收过程中的停顿时间</font><font style="color:rgb(6, 6, 7);">。 - </font>**<font style="color:rgb(6, 6, 7);">并发操作</font>**<font style="color:rgb(6, 6, 7);">：大部分操作与应用程序线程并发执行，减少对应用程序性能的影响</font><font style="color:rgb(6, 6, 7);">。 - </font>**<font style="color:rgb(6, 6, 7);">收集阶段</font>**<font style="color:rgb(6, 6, 7);">：具体阶段与ZGC收集器类似，主要包括并发标记、并发清理等阶段，但具体实现细节和优化策略有所不同。</font>

<font style="color:rgb(6, 6, 7);">● </font>**<font style="color:rgb(6, 6, 7);">G1（Garbage First）收集器</font>**<font style="color:rgb(6, 6, 7);">： - </font>**<font style="color:rgb(6, 6, 7);">算法</font>**<font style="color:rgb(6, 6, 7);">：基于标记-整理算法，局部（Region之间）可能采用复制算法</font><font style="color:rgb(6, 6, 7);">。 - </font>**<font style="color:rgb(6, 6, 7);">特点</font>**<font style="color:rgb(6, 6, 7);">： - </font>**<font style="color:rgb(6, 6, 7);">区域化管理</font>**<font style="color:rgb(6, 6, 7);">：将堆划分为多个Region，根据垃圾回收收益优先回收垃圾最多的区域</font><font style="color:rgb(6, 6, 7);">。 - </font>**<font style="color:rgb(6, 6, 7);">预测性控制</font>**<font style="color:rgb(6, 6, 7);">：可通过参数设置最大停顿时间，减少全堆扫描，避免了CMS的内存碎片问题</font><font style="color:rgb(6, 6, 7);">。 - </font>**<font style="color:rgb(6, 6, 7);">平衡性能</font>**<font style="color:rgb(6, 6, 7);">：试图平衡吞吐量和延迟，适用于大堆内存且对延迟敏感的应用</font><font style="color:rgb(6, 6, 7);">。 - </font>**<font style="color:rgb(6, 6, 7);">收集阶段</font>**<font style="color:rgb(6, 6, 7);">： - </font>**<font style="color:rgb(6, 6, 7);">初始标记</font>**<font style="color:rgb(6, 6, 7);">：标记与GC Roots直接关联的对象，需要暂停用户线程（STW）</font><font style="color:rgb(6, 6, 7);">。 - </font>**<font style="color:rgb(6, 6, 7);">并发标记</font>**<font style="color:rgb(6, 6, 7);">：遍历对象图标记所有可达对象，此阶段用户线程继续运行</font><font style="color:rgb(6, 6, 7);">。 - </font>**<font style="color:rgb(6, 6, 7);">最终标记</font>**<font style="color:rgb(6, 6, 7);">：修正引用变化，需要暂停用户线程</font><font style="color:rgb(6, 6, 7);">。 - </font>**<font style="color:rgb(6, 6, 7);">筛选回收</font>**<font style="color:rgb(6, 6, 7);">：按回收价值优先回收垃圾最多的区域</font><font style="color:rgb(6, 6, 7);">。</font>

<font style="color:rgb(6, 6, 7);">● </font>**<font style="color:rgb(6, 6, 7);">CMS（Concurrent Mark Sweep）收集器</font>**<font style="color:rgb(6, 6, 7);">： - </font>**<font style="color:rgb(6, 6, 7);">算法</font>**<font style="color:rgb(6, 6, 7);">：基于标记-清除算法。 - </font>**<font style="color:rgb(6, 6, 7);">特点</font>**<font style="color:rgb(6, 6, 7);">： - </font>**<font style="color:rgb(6, 6, 7);">低延迟</font>**<font style="color:rgb(6, 6, 7);">：以减少停顿时间为目标，适用于对延迟敏感的应用场景，如Web服务器。 - </font>**<font style="color:rgb(6, 6, 7);">并发执行</font>**<font style="color:rgb(6, 6, 7);">：标记和清除阶段大部分与用户线程并发执行，显著降低了STW时间。 - </font>**<font style="color:rgb(6, 6, 7);">内存碎片</font>**<font style="color:rgb(6, 6, 7);">：由于采用标记-清除算法，可能会产生内存碎片，可通过合理设置参数在减少内存碎片与降低停顿时间之间找到平衡。 - </font>**<font style="color:rgb(6, 6, 7);">收集阶段</font>**<font style="color:rgb(6, 6, 7);">： - </font>**<font style="color:rgb(6, 6, 7);">初始标记</font>**<font style="color:rgb(6, 6, 7);">：标记与GC Roots直接关联的对象，需要暂停用户线程，过程非常快 。 - </font>**<font style="color:rgb(6, 6, 7);">并发标记</font>**<font style="color:rgb(6, 6, 7);">：从GC Roots的直接关联对象开始遍历整个对象图，标记所有可达对象，此阶段耗时长但不需要暂停用户线程，可以和垃圾收集器线程一起并发运行 。 - </font>**<font style="color:rgb(6, 6, 7);">重新标记</font>**<font style="color:rgb(6, 6, 7);">：修正并发标记期间因用户线程程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段暂停时间比初始标记阶段稍长一点，但远比并发标记时间段短 。 - </font>**<font style="color:rgb(6, 6, 7);">并发清除</font>**<font style="color:rgb(6, 6, 7);">：清除掉已经被判定死亡的对象，这个阶段可以和用户线程并发运行 。</font>

