---
layout: post
title: "《深入理解jvm虚拟机》"
date:   2025-1-16
tags: [tag1, tag2]
comments: true
author: huanghuoguoguo
---

1.14开

## java历史粗看


## 关于GC
看此书的目的的确是为了了解更底层的知识，加之之前学习的基础。感觉自己已经可以初步查看。

+ 从早期版本开始出现的串行，到后面的并行。然后到gc线程和用户线程并发。每一个垃圾收集器都是为了解决问题，但是都没有达到最好的效果，直到zgc出现，可以说达到了一个兼顾的比较好的效果，但是具体情况还是要具体分析，选择适合的业务的垃圾收集器。
+ 重点关注后四个gc，cms，g1，shen，zgc，共同点，gc root有关的都stw，都并发标记，都stw整理并发标记之后的归档。只有移动对象且并发的时候才会要求处理不正确的指引，像cms，因为是清除算法，所以最后清除的时候不需要stw，因为不需要维护指向对象的指针。而像g1，因为需要移动对象，而没有提供额外的并发手段，所以在移动对象的时候需要stw。
    - cms，作用于老年代的收集，标记清除算法，会有碎片。处理并发标记过程产生的变化不能并发，最后的清除阶段需要stw。<font style="color:rgb(6, 6, 7);">CMS的清除阶段是并发执行的，但确实有一个短暂的STW阶段用于处理一些最终的修正工作。</font>
    - g1，分region，region也分代，标记整理算法，satb处理并发标记过程中的遗漏。新生代多用标记复制，因为新生代多数会被清理，如果不复制规整，会产生很多内存碎片。**<font style="color:rgb(6, 6, 7);">筛选回收</font>**<font style="color:rgb(6, 6, 7);">：根据回收价值选择Region进行回收，此阶段涉及对象移动，需要暂停用户线程。</font>
    - <font style="color:rgb(6, 6, 7);">Shenandoah</font>，标记整理，使用<font style="color:rgb(6, 6, 7);">brooks pointer</font>转发，最后阶段也可以并发。读屏障等技术。
    - zgc，jdk21之后分代，并发标记，并发清除和整理，通过染色指针和多重虚拟内存映射，将额外的payload放到指针中，44-48位。同时优化了cache line问题，优化了伪共享。能够保持极低的延迟。也用到了读屏障。

### <font style="color:rgb(6, 6, 7);">垃圾收集器的处理机制</font>
1. **<font style="color:rgb(6, 6, 7);">CMS（Concurrent Mark Sweep）</font>**
    - **<font style="color:rgb(6, 6, 7);">标记-清除算法</font>**<font style="color:rgb(6, 6, 7);">：CMS使用标记-清除算法，不会移动对象，只是清除未标记的对象。</font>
    - **<font style="color:rgb(6, 6, 7);">不需要STW来维护旧指针</font>**<font style="color:rgb(6, 6, 7);">：因为对象没有移动，所以不需要处理指针的更新问题。CMS在并发标记和并发清除阶段与用户线程并发执行，但确实有一个短暂的STW阶段用于处理并发标记过程中产生的变化（重新标记阶段）。</font>
2. **<font style="color:rgb(6, 6, 7);">G1（Garbage First）</font>**
    - **<font style="color:rgb(6, 6, 7);">标记-整理算法</font>**<font style="color:rgb(6, 6, 7);">：G1使用标记-整理算法，会移动对象。</font>
    - **<font style="color:rgb(6, 6, 7);">需要STW来处理指针更新</font>**<font style="color:rgb(6, 6, 7);">：在筛选回收阶段，G1会移动存活对象到新的Region，这个过程需要暂停用户线程（STW）来更新指针，确保引用的正确性。</font>
3. **<font style="color:rgb(6, 6, 7);">Shenandoah</font>**
    - **<font style="color:rgb(6, 6, 7);">标记-整理算法</font>**<font style="color:rgb(6, 6, 7);">：Shenandoah使用标记-整理算法，会移动对象。</font>
    - **<font style="color:rgb(6, 6, 7);">并发指针更新</font>**<font style="color:rgb(6, 6, 7);">：Shenandoah在并发重定位阶段会移动对象，并且使用Brooks Pointer转发技术来更新指针，这个过程是并发执行的，不需要STW来处理指针更新。</font>
4. **<font style="color:rgb(6, 6, 7);">ZGC（Z Garbage Collector）</font>**
    - **<font style="color:rgb(6, 6, 7);">标记-整理算法</font>**<font style="color:rgb(6, 6, 7);">：ZGC使用标记-整理算法，会移动对象。</font>
    - **<font style="color:rgb(6, 6, 7);">并发指针更新</font>**<font style="color:rgb(6, 6, 7);">：ZGC在并发重定位阶段会移动对象，并且使用染色指针技术来更新指针，这个过程是并发执行的，不需要STW来处理指针更新。</font>

### <font style="color:rgb(6, 6, 7);">总结</font>
+ **<font style="color:rgb(6, 6, 7);">CMS</font>**<font style="color:rgb(6, 6, 7);">：因为不移动对象，所以不需要处理指针更新问题，但需要一个短暂的STW阶段来处理并发标记过程中产生的变化。</font>
+ **<font style="color:rgb(6, 6, 7);">G1</font>**<font style="color:rgb(6, 6, 7);">：需要移动对象，因此需要STW来处理指针更新。</font>
+ **<font style="color:rgb(6, 6, 7);">Shenandoah</font>**<font style="color:rgb(6, 6, 7);">：需要移动对象，但使用Brooks Pointer转发技术在并发阶段更新指针，不需要STW来处理指针更新。</font>
+ **<font style="color:rgb(6, 6, 7);">ZGC</font>**<font style="color:rgb(6, 6, 7);">：需要移动对象，但使用染色指针技术在并发阶段更新指针，不需要STW来处理指针更新。</font>

<font style="color:rgb(6, 6, 7);">理解基本正确，但需要明确的是，CMS虽然不需要处理指针更新，但仍然有一个短暂的STW阶段用于处理并发标记过程中产生的变化。其他算法（G1、Shenandoah、ZGC）在移动对象时，需要处理指针更新，但具体处理方式有所不同，G1需要STW，而Shenandoah和ZGC可以并发处理。</font>

<font style="color:rgb(6, 6, 7);"></font>

<font style="color:rgb(6, 6, 7);">这一章的最后还列举了一些具体的场景。</font>

## <font style="color:rgb(6, 6, 7);">java工具</font>
包括像jmap，jhat，jstat，jstack等那一套，除了列举这些属性，最后也说了一下使用实战。不过因为缺少经验，这部分粗看。



## class文件
虚拟机只认识class文件，讲了class文件的结构，从开始的魔数到后面的函数表，字段表，异常表，也补充了一些jvm字节码指令的知识。粗看。

## 类加载机制
编译、加载、连接（验证、准备、解析）初始化、使用、卸载。

只有遇到new、getstatic、putstatic、invokestatic四个字节码指令才会触发初始化。访问final修饰的静态常量（不是从方法定义，就是字面常量）的时候，因为常量内联，不会触发初始化。数组也不会触发初始化。但是都会触发加载吧？

## 类加载器
boot，ext，custom

loadclass，findclass，difineclass

jdk9引入了模块化

### <font style="color:rgb(6, 6, 7);">加载（Loading）</font>
+ **<font style="color:rgb(6, 6, 7);">任务</font>**<font style="color:rgb(6, 6, 7);">：将字节码文件（</font>`.class`<font style="color:rgb(6, 6, 7);">）读入内存，并创建一个</font><font style="color:rgb(6, 6, 7);"> </font>`java.lang.Class`<font style="color:rgb(6, 6, 7);"> </font><font style="color:rgb(6, 6, 7);">对象。</font>
+ **<font style="color:rgb(6, 6, 7);">具体操作</font>**<font style="color:rgb(6, 6, 7);">：</font>
    - <font style="color:rgb(6, 6, 7);">从文件系统、网络或其他来源读取字节码文件。</font>
    - <font style="color:rgb(6, 6, 7);">将字节码文件的内容转换为方法区中的运行时数据结构。</font>
    - <font style="color:rgb(6, 6, 7);">创建一个</font><font style="color:rgb(6, 6, 7);"> </font>`java.lang.Class`<font style="color:rgb(6, 6, 7);"> </font><font style="color:rgb(6, 6, 7);">对象，表示这个类。</font>

### <font style="color:rgb(6, 6, 7);">2. 验证（Verification）</font>
+ **<font style="color:rgb(6, 6, 7);">任务</font>**<font style="color:rgb(6, 6, 7);">：确保加载的字节码文件是正确的，没有安全问题。</font>
+ **<font style="color:rgb(6, 6, 7);">具体操作</font>**<font style="color:rgb(6, 6, 7);">：</font>
    - <font style="color:rgb(6, 6, 7);">检查字节码文件的格式是否正确。</font>
    - <font style="color:rgb(6, 6, 7);">检查类的结构是否符合 Java 语言规范。</font>
    - <font style="color:rgb(6, 6, 7);">检查方法的字节码是否合法，例如类型检查、操作数栈的溢出和下溢检查等。</font>

### <font style="color:rgb(6, 6, 7);">3. 准备（Preparation）</font>
+ **<font style="color:rgb(6, 6, 7);">任务</font>**<font style="color:rgb(6, 6, 7);">：为类的静态变量分配内存，并设置默认初始值。</font>
+ **<font style="color:rgb(6, 6, 7);">具体操作</font>**<font style="color:rgb(6, 6, 7);">：</font>
    - <font style="color:rgb(6, 6, 7);">为类的静态变量分配内存。</font>
    - <font style="color:rgb(6, 6, 7);">设置静态变量的默认值，例如</font><font style="color:rgb(6, 6, 7);"> </font>`int`<font style="color:rgb(6, 6, 7);"> </font><font style="color:rgb(6, 6, 7);">类型的静态变量默认初始化为</font><font style="color:rgb(6, 6, 7);"> </font>`0`<font style="color:rgb(6, 6, 7);">，</font>`boolean`<font style="color:rgb(6, 6, 7);"> </font><font style="color:rgb(6, 6, 7);">类型的静态变量默认初始化为</font><font style="color:rgb(6, 6, 7);"> </font>`false`<font style="color:rgb(6, 6, 7);"> </font><font style="color:rgb(6, 6, 7);">等。</font>

### <font style="color:rgb(6, 6, 7);">4. 解析（Resolution）</font>
+ **<font style="color:rgb(6, 6, 7);">任务</font>**<font style="color:rgb(6, 6, 7);">：将类、接口、字段和方法的符号引用转换为直接引用。</font>
+ **<font style="color:rgb(6, 6, 7);">具体操作</font>**<font style="color:rgb(6, 6, 7);">：</font>
    - <font style="color:rgb(6, 6, 7);">解析类和接口的符号引用，确保它们在方法区中存在。</font>
    - <font style="color:rgb(6, 6, 7);">解析字段和方法的符号引用，确保它们在类或接口中存在，并且可以被访问。</font>
    - <font style="color:rgb(6, 6, 7);">解析类字面量（如</font><font style="color:rgb(6, 6, 7);"> </font>`String.class`<font style="color:rgb(6, 6, 7);">）的符号引用。</font>

### <font style="color:rgb(6, 6, 7);">总结</font>
+ **<font style="color:rgb(6, 6, 7);">加载</font>**<font style="color:rgb(6, 6, 7);">：读取字节码文件，创建</font><font style="color:rgb(6, 6, 7);"> </font>`Class`<font style="color:rgb(6, 6, 7);"> </font><font style="color:rgb(6, 6, 7);">对象。</font>
+ **<font style="color:rgb(6, 6, 7);">验证</font>**<font style="color:rgb(6, 6, 7);">：确保字节码文件正确且安全。</font>
+ **<font style="color:rgb(6, 6, 7);">准备</font>**<font style="color:rgb(6, 6, 7);">：为静态变量分配内存并设置默认值。</font>
+ **<font style="color:rgb(6, 6, 7);">解析</font>**<font style="color:rgb(6, 6, 7);">：将符号引用转换为直接引用。</font>

<font style="color:rgb(6, 6, 7);">这些阶段共同确保了类在加载到 JVM 时是正确和安全的，并且可以被正确地使用。</font>

<font style="color:rgb(6, 6, 7);"></font>

## <font style="color:rgb(6, 6, 7);">jvm中的子系统</font>
类加载子系统

运行时数据区

执行引擎子系统

本地接口子系统

线程管理子系统

安全子系统

内存管理子系统

监控和管理子系统





# 目录




<font style="color:rgb(17, 17, 17);">第一部分（第1章）走近Java</font>

<font style="color:rgb(17, 17, 17);">系统介绍了Java的技术体系、发展历程、虚拟机家族，以及动手编译JDK，了解这部分内容能对学习JVM提供良好的指引。</font>

<font style="color:rgb(17, 17, 17);">第二部分（第2~5章）自动内存管理</font>

<font style="color:rgb(17, 17, 17);">详细讲解了Java的内存区域与内存溢出、垃圾收集器与内存分配策略、虚拟机性能监控与故障排除等与自动内存管理相关的内容，以及10余个经典的性能优化案例和优化方法；</font>

<font style="color:rgb(17, 17, 17);">第三部分（第6~9章）虚拟机执行子系统</font>

<font style="color:rgb(17, 17, 17);">深入分析了虚拟机执行子系统，包括类文件结构、虚拟机类加载机制、虚拟机字节码执行引擎，以及多个类加载及其执行子系统的实战案例；</font>

<font style="color:rgb(17, 17, 17);">第四部分（第10~11章）程序编译与代码优化</font>

<font style="color:rgb(17, 17, 17);">详细讲解了程序的前、后端编译与优化，包括前端的易用性优化措施，如泛型、主动装箱拆箱、条件编译等的内容的深入分析；以及后端的性能优化措施，如虚拟机的热点探测方法、HotSpot 的即时编译器、提前编译器，以及各种常见的编译期优化技术；</font>

<font style="color:rgb(17, 17, 17);">第五部分（第12~13章）高效并发</font>

<font style="color:rgb(17, 17, 17);">主要讲解了Java实现高并发的原理，包括Java的内存模型、线程与协程，以及线程安全和锁优化。</font>





### <font style="color:rgb(0, 0, 0);">第二章 Java内存区域与内存溢出异常</font>
#### <font style="color:rgb(51, 51, 51);">2.2 运行时数据区域</font>
+ <font style="color:rgb(0, 0, 0);">p42 Java内存区域划分概述</font>
+ <font style="color:rgb(0, 0, 0);">p43 程序计数器</font>
+ <font style="color:rgb(0, 0, 0);">p43 程序计数器是唯一一个不会存在OOM的内存区域</font>
+ <font style="color:rgb(0, 0, 0);">p43 Java虚拟机栈</font>
+ <font style="color:rgb(0, 0, 0);">p44 局部变量槽</font>
+ <font style="color:rgb(0, 0, 0);">p44 本地方法栈</font>
+ <font style="color:rgb(0, 0, 0);">p44 Java堆</font>
+ <font style="color:rgb(0, 0, 0);">p45 分配缓冲区TLAB</font>
+ <font style="color:rgb(0, 0, 0);">p46 方法区</font>
+ <font style="color:rgb(0, 0, 0);">p46 永久代（持久代）</font>
+ <font style="color:rgb(0, 0, 0);">p47 运行时常量池</font>
+ <font style="color:rgb(0, 0, 0);">p47 直接内存</font>

#### <font style="color:rgb(51, 51, 51);">2.3 HotSpot虚拟机对象探秘</font>
+ <font style="color:rgb(0, 0, 0);">p48 对象的创建</font>
+ <font style="color:rgb(0, 0, 0);">p48 类加载检查</font>
+ <font style="color:rgb(0, 0, 0);">p48 为新生对象分配内存</font>
+ <font style="color:rgb(0, 0, 0);">p48 内存分配方式-指针碰撞</font>
+ <font style="color:rgb(0, 0, 0);">p48 内存分配方式-空闲列表</font>
+ <font style="color:rgb(0, 0, 0);">p48 空间压缩整理</font>
+ <font style="color:rgb(0, 0, 0);">p48 清除算法</font>
+ <font style="color:rgb(0, 0, 0);">p49 本地线程分配缓冲</font>
+ <font style="color:rgb(0, 0, 0);">p49 Java虚拟机对对象进行必要的设置</font>
+ <font style="color:rgb(0, 0, 0);">p51 对象的内存布局</font>
+ <font style="color:rgb(0, 0, 0);">p51 对象头</font>
+ <font style="color:rgb(0, 0, 0);">p51 对象头-对象自身运行时数据</font>
+ <font style="color:rgb(0, 0, 0);">p51 对象头-类型指针</font>
+ <font style="color:rgb(0, 0, 0);">p51 类型元数据</font>
+ <font style="color:rgb(0, 0, 0);">p52 实例数据</font>
+ <font style="color:rgb(0, 0, 0);">p52 对齐填充</font>
+ <font style="color:rgb(0, 0, 0);">p52 对象的访问定位</font>
+ <font style="color:rgb(0, 0, 0);">p52 句柄访问</font>
+ <font style="color:rgb(0, 0, 0);">p52 直接指针访问</font>

#### <font style="color:rgb(51, 51, 51);">2.4 实战：OutOfMemoryError异常</font>
+ <font style="color:rgb(0, 0, 0);">p54 Java堆溢出</font>
+ <font style="color:rgb(0, 0, 0);">p55 堆的最小值参数 -Xms</font>
+ <font style="color:rgb(0, 0, 0);">p55 堆的最大值参数 -Xmx</font>
+ <font style="color:rgb(0, 0, 0);">p55 生成堆转储快照参数-XX:+HeapDumpOnOutOfMemoryError</font>
+ <font style="color:rgb(0, 0, 0);">p55 OutOfMemoryError异常-堆溢出</font>
+ <font style="color:rgb(0, 0, 0);">p55 内存映像分析工具</font>
+ <font style="color:rgb(0, 0, 0);">p55 堆内存溢出解决方案</font>
+ <font style="color:rgb(0, 0, 0);">p56 虚拟机栈和本地方法栈溢出</font>
+ <font style="color:rgb(0, 0, 0);">p57 StackOverflowError异常（请求的栈深度大于虚拟机所允许的最大深度）</font>
+ <font style="color:rgb(0, 0, 0);">p57 OutOfMemoryError异常-栈溢出（扩展栈时申请不到足够内存）</font>
+ <font style="color:rgb(0, 0, 0);">p57 栈内存容量参数 -Xss</font>
+ <font style="color:rgb(0, 0, 0);">p60 不断创建线程来产生OutOfMemoryError</font>
+ <font style="color:rgb(0, 0, 0);">p61 方法区和运行时常量池溢出</font>
+ <font style="color:rgb(0, 0, 0);">p61 String.intern()方法</font>
+ <font style="color:rgb(0, 0, 0);">p62 JDK7起，原本存放在永久代的字符串常量池被移至Java堆之中</font>
+ <font style="color:rgb(0, 0, 0);">p63 JDK6和JDK7及以后版本在字符串常量池实现上差异的示例</font>
+ <font style="color:rgb(0, 0, 0);">p64 制造方法区溢出-CGLib直接操作字节码运行时生成大量的动态类</font>
+ <font style="color:rgb(0, 0, 0);">p65 可能生成大量动态类，导致方法区溢出的场景</font>
+ <font style="color:rgb(0, 0, 0);">p65 HotSpot提供的元空间防御参数</font>
+ <font style="color:rgb(0, 0, 0);">p65 本机直接内存溢出</font>
+ <font style="color:rgb(0, 0, 0);">p65 参数 -XX:MaxDirectMemorySize</font>
+ <font style="color:rgb(0, 0, 0);">p66 直接内存导致的内存溢出的明显特征</font>

### <font style="color:rgb(0, 0, 0);">第三章 垃圾收集器与内存分配策略</font>
#### <font style="color:rgb(51, 51, 51);">3.2 对象已死？</font>
+ <font style="color:rgb(0, 0, 0);">p68 引用计数算法</font>
+ <font style="color:rgb(0, 0, 0);">P70 可达性分析算法</font>
+ <font style="color:rgb(0, 0, 0);">p70 GC Roots</font>
+ <font style="color:rgb(0, 0, 0);">p70 引用链</font>
+ <font style="color:rgb(0, 0, 0);">p70 可作为GC Roots的对象</font>
+ <font style="color:rgb(0, 0, 0);">p71 再谈引用</font>
+ <font style="color:rgb(0, 0, 0);">p71 Java引用按强度的四种分类（强引用、软引用、弱引用、虚引用）</font>
+ <font style="color:rgb(0, 0, 0);">p72 生存还是死亡？</font>
+ <font style="color:rgb(0, 0, 0);">p72 宣告对象死亡的两次标记过程</font>
+ <font style="color:rgb(0, 0, 0);">p72 Finalizer线程</font>
+ <font style="color:rgb(0, 0, 0);">p73 判断对象死亡的流程</font>
+ <font style="color:rgb(0, 0, 0);">p73 finalize()方法只会被自动调用一次</font>
+ <font style="color:rgb(0, 0, 0);">p74 回收方法区</font>
+ <font style="color:rgb(0, 0, 0);">p74 方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型</font>

#### <font style="color:rgb(51, 51, 51);">3.3 垃圾收集算法</font>
+ <font style="color:rgb(0, 0, 0);">p75 垃圾收集算法</font>
+ <font style="color:rgb(0, 0, 0);">p75 直接垃圾收集和间接垃圾收集</font>
+ <font style="color:rgb(0, 0, 0);">p75 分代收集</font>
+ <font style="color:rgb(0, 0, 0);">p75 分代假说（弱分代假说、强分代假说、跨代引用假说）</font>
+ <font style="color:rgb(0, 0, 0);">p75 垃圾收集的一致设计原则</font>
+ <font style="color:rgb(0, 0, 0);">p76 新生代和老年代</font>
+ <font style="color:rgb(0, 0, 0);">p76 Minor GC(仅限于新生代的收集)、Full GC(面向整个堆的收集)</font>
+ <font style="color:rgb(0, 0, 0);">p77 处理跨代引用的记忆集设计</font>
+ <font style="color:rgb(0, 0, 0);">p77 分代相关名词的定义（分代种类）</font>
+ <font style="color:rgb(0, 0, 0);">p77 标记-清除算法</font>
+ <font style="color:rgb(0, 0, 0);">P78 标记-复制算法</font>
+ <font style="color:rgb(0, 0, 0);">p79 Appel式回收（Eden、Survivor）</font>
+ <font style="color:rgb(0, 0, 0);">p79 "逃生门"设计</font>
+ <font style="color:rgb(0, 0, 0);">p79 标记-整理算法</font>
+ <font style="color:rgb(0, 0, 0);">p79 移动式回收算法</font>
+ <font style="color:rgb(0, 0, 0);">p80 吞吐量的实质是赋值器（用户程序）与收集器效率的总和</font>

#### <font style="color:rgb(51, 51, 51);">3.4 HotSpot的算法细节实现</font>
+ <font style="color:rgb(0, 0, 0);">p81 根节点枚举</font>
+ <font style="color:rgb(0, 0, 0);">p81 OopMap</font>
+ <font style="color:rgb(0, 0, 0);">p82 安全点</font>
+ <font style="color:rgb(0, 0, 0);">p82 安全点位置选取</font>
+ <font style="color:rgb(0, 0, 0);">p82 抢先式中断和主动式中断</font>
+ <font style="color:rgb(0, 0, 0);">p83 安全区域</font>
+ <font style="color:rgb(0, 0, 0);">p84 记忆集和卡表</font>
+ <font style="color:rgb(0, 0, 0);">p84 记忆集</font>
+ <font style="color:rgb(0, 0, 0);">p84 卡表（记忆集的一种实现形式）</font>
+ <font style="color:rgb(0, 0, 0);">p85 写屏障（在写的前后执行某种操作）</font>
+ <font style="color:rgb(0, 0, 0);">p86 伪共享问题及其解决方案</font>
+ <font style="color:rgb(0, 0, 0);">p87 并发的可达性分析</font>
+ <font style="color:rgb(0, 0, 0);">p87 为什么必须在一个能保障一致性的快照上才能进行对象图的遍历</font>
+ <font style="color:rgb(0, 0, 0);">p87 三色标记</font>
+ <font style="color:rgb(0, 0, 0);">p88 "对象消失"问题的示意图</font>
+ <font style="color:rgb(0, 0, 0);">p89 "对象消失"问题发生的充分必要条件（要求两条同时满足）</font>
+ <font style="color:rgb(0, 0, 0);">p89 "对象消失"问题的两种解决方案：增量更新和原始快照SATB</font>

#### <font style="color:rgb(51, 51, 51);">3.5 经典垃圾收集器</font>
+ <font style="color:rgb(0, 0, 0);">p90 HotSpot虚拟机的经典垃圾收集器关系图</font>
+ <font style="color:rgb(0, 0, 0);">p91 Stop The World</font>
+ <font style="color:rgb(0, 0, 0);">p90 Serial收集器</font>
+ <font style="color:rgb(0, 0, 0);">p92 ParNew收集器</font>
+ <font style="color:rgb(0, 0, 0);">p93 并发和并行</font>
+ <font style="color:rgb(0, 0, 0);">p93 Parallel Scavenge收集器（一种以获取最大吞吐量为目的的收集器）</font>
+ <font style="color:rgb(0, 0, 0);">p93 吞吐量指处理器用于运行用户代码的时间与处理器总消耗时间的比值</font>
+ <font style="color:rgb(0, 0, 0);">p94 垃圾收集停顿时间指进行一次垃圾收集所需的时间</font>
+ <font style="color:rgb(0, 0, 0);">p94 垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的</font>
+ <font style="color:rgb(0, 0, 0);">p94 垃圾收集的自适应调节策略</font>
+ <font style="color:rgb(0, 0, 0);">p94 Serial Old收集器</font>
+ <font style="color:rgb(0, 0, 0);">p95 Parallel Old收集器</font>
+ <font style="color:rgb(0, 0, 0);">p96 CMS收集器（一种以获取最短回收停顿时间为目的的收集器）</font>
+ <font style="color:rgb(0, 0, 0);">p96 CMS收集器收集的四个步骤（初始标记-并发标记-重新标记-并发清除）</font>
+ <font style="color:rgb(0, 0, 0);">p97 CMS三个明显缺点（对处理器资源敏感、无法处理浮动垃圾、大量空间碎片）</font>
+ <font style="color:rgb(0, 0, 0);">p97 增量式并发收集器</font>
+ <font style="color:rgb(0, 0, 0);">p97 浮动垃圾</font>
+ <font style="color:rgb(0, 0, 0);">p97 并发失败</font>
+ <font style="color:rgb(0, 0, 0);">p98 Garbage First收集器（G1收集器）</font>
+ <font style="color:rgb(0, 0, 0);">p99 统一垃圾收集器接口</font>
+ <font style="color:rgb(0, 0, 0);">p99 Mixed GC模式</font>
+ <font style="color:rgb(0, 0, 0);">p99 G1开创的基于Region的堆内存布局</font>
+ <font style="color:rgb(0, 0, 0);">p99 用于存储大对象的Humongous区域</font>
+ <font style="color:rgb(0, 0, 0);">p99 具有优先级的区域回收方式实现</font>
+ <font style="color:rgb(0, 0, 0);">p100 G1收集器的Region中存在的跨Region引用对象如何解决（跨代引用问题）</font>
+ <font style="color:rgb(0, 0, 0);">p101 G1收集器的并发标记阶段如何保证收集线程与用户线程不干扰地运行</font>
+ <font style="color:rgb(0, 0, 0);">p101 TAMS指针-解决并发标记、回收阶段的新对象创建问题</font>
+ <font style="color:rgb(0, 0, 0);">p101 G1收集器怎样建立起可靠的停顿预测模型</font>
+ <font style="color:rgb(0, 0, 0);">p101 衰减均值</font>
+ <font style="color:rgb(0, 0, 0);">p101 G1收集器运作的四个步骤（初始标记-并发标记-最终标记-筛选回收）</font>
+ <font style="color:rgb(0, 0, 0);">p102 用户指定期望的停顿时间是G1收集器很强大的一个功能</font>
+ <font style="color:rgb(0, 0, 0);">p103 G1收集器与CMS收集器的比较</font>
+ <font style="color:rgb(0, 0, 0);">p103 G1运作期间不会产生内存空间碎片</font>
+ <font style="color:rgb(0, 0, 0);">p103 G1在维护卡表时不光需要使用写后屏障，为了实现SATB，还要使用写前屏障</font>
+ <font style="color:rgb(0, 0, 0);">p103 G1中使用原始快照而不是增量更新的理由-减少并发标记和重新标记阶段的消耗</font>

#### <font style="color:rgb(51, 51, 51);">3.6 低延迟垃圾收集器</font>
+ <font style="color:rgb(0, 0, 0);">p104 衡量垃圾收集器的三项重要指标（内存占用、吞吐量、延迟）</font>
+ <font style="color:rgb(0, 0, 0);">p105 各款收集器的并发情况</font>
+ <font style="color:rgb(0, 0, 0);">p105 低延迟垃圾收集器</font>
+ <font style="color:rgb(0, 0, 0);">p105 Shenandoah收集器</font>
+ <font style="color:rgb(0, 0, 0);">p106 Shenandoah与G1的三个不同之处（支持并发整理算法、不使用分代收集、放弃记忆集而使用连接矩阵）</font>
+ <font style="color:rgb(0, 0, 0);">p106 Shenandoah收集器的工作过程（九个阶段）</font>
+ <font style="color:rgb(0, 0, 0);">p108 Brooks Pointer</font>
+ <font style="color:rgb(0, 0, 0);">p109 Brooks形式转发指针的多线程竞争问题</font>
+ <font style="color:rgb(0, 0, 0);">p110 读屏障</font>
+ <font style="color:rgb(0, 0, 0);">p111 引用访问屏障</font>
+ <font style="color:rgb(0, 0, 0);">p112 ZGC收集器</font>
+ <font style="color:rgb(0, 0, 0);">p112 ZGC的动态Region</font>
+ <font style="color:rgb(0, 0, 0);">p113 染色指针技术</font>
+ <font style="color:rgb(0, 0, 0);">p115 染色指针三大优势</font>
+ <font style="color:rgb(0, 0, 0);">p116 多重映射</font>
+ <font style="color:rgb(0, 0, 0);">p117 ZGC的运作过程（并发标记-并发预备重分配-并发重分配-并发重映射）</font>
+ <font style="color:rgb(0, 0, 0);">p117 指针的自愈能力</font>
+ <font style="color:rgb(0, 0, 0);">p118 ZGC不使用记忆集的优劣</font>
+ <font style="color:rgb(0, 0, 0);">p119 "NUMA-Aware"内存分配</font>

#### <font style="color:rgb(51, 51, 51);">3.7 选择合适的垃圾收集器</font>
+ <font style="color:rgb(0, 0, 0);">p121 Epsilon收集器</font>
+ <font style="color:rgb(0, 0, 0);">p121 收集器的权衡</font>
+ <font style="color:rgb(0, 0, 0);">p122 虚拟机及垃圾收集器日志</font>
+ <font style="color:rgb(0, 0, 0);">p123 HotSpot功能日志参数-Xlog</font>
+ <font style="color:rgb(0, 0, 0);">p123 虚拟机日志级别</font>
+ <font style="color:rgb(0, 0, 0);">p124 如何通过虚拟机参数获得垃圾收集器过程的相关信息</font>
+ <font style="color:rgb(0, 0, 0);">p127 垃圾收集器参数总结</font>

#### <font style="color:rgb(51, 51, 51);">3.8 实战：内存分配与回收策略</font>
+ <font style="color:rgb(0, 0, 0);">p129 Java自动内存管理的根本目标（自动给对象分配内存、自动回收分配给对象的内存）</font>
+ <font style="color:rgb(0, 0, 0);">p130 对象优先在Eden分配</font>
+ <font style="color:rgb(0, 0, 0);">p130 内存空间分配担保机制（后面有更详细的解释p135）</font>
+ <font style="color:rgb(0, 0, 0);">P131 大对象直接进入老年代</font>
+ <font style="color:rgb(0, 0, 0);">p131 -XX:PretenureSizeThreshold参数（直接在老年代分配大对象）</font>
+ <font style="color:rgb(0, 0, 0);">p132 长期存活的对象将进入老年代</font>
+ <font style="color:rgb(0, 0, 0);">p132 对象年龄计数器</font>
+ <font style="color:rgb(0, 0, 0);">p132 -XX:MaxTenuringThreshold参数（设置对象晋升到老年代的阈值）</font>
+ <font style="color:rgb(0, 0, 0);">p134 动态对象年龄判定</font>
+ <font style="color:rgb(0, 0, 0);">p135 空间分配担保</font>

### <font style="color:rgb(0, 0, 0);">第四章 虚拟机性能监控、故障处理工具</font>
#### <font style="color:rgb(51, 51, 51);">4.2 基础故障处理工具</font>
+ <font style="color:rgb(0, 0, 0);">p139 JDK中基础故障处理工具的三个分类</font>
+ <font style="color:rgb(0, 0, 0);">p141 jps - 虚拟机进程状况工具</font>
+ <font style="color:rgb(0, 0, 0);">p142 jstat - 虚拟机统计信息监视工具</font>
+ <font style="color:rgb(0, 0, 0);">p143 jinfo - Java配置信息工具</font>
+ <font style="color:rgb(0, 0, 0);">p144 jmap - Java内存映像工具</font>
+ <font style="color:rgb(0, 0, 0);">p145 jhat - 虚拟机堆转储快照分析工具（JDK9后被弃用）</font>
+ <font style="color:rgb(0, 0, 0);">p146 jstack - Java堆栈跟踪工具</font>
+ <font style="color:rgb(0, 0, 0);">p146 线程快照</font>
+ <font style="color:rgb(0, 0, 0);">p147 Thread类的getAllStackTraces()方法</font>
+ <font style="color:rgb(0, 0, 0);">p148 JDK基础工具总结</font>

#### <font style="color:rgb(51, 51, 51);">4.3 可视化故障处理工具</font>
+ <font style="color:rgb(0, 0, 0);">p152 JHSDB - 基于服务性代理的调试工具</font>
+ <font style="color:rgb(0, 0, 0);">p157 JConsole - Java监视与管理控制台</font>
+ <font style="color:rgb(0, 0, 0);">p160 线程长时间停顿的主要原因（等待外部资源、死循环、锁等待）</font>
+ <font style="color:rgb(0, 0, 0);">p164 VisualVM - 多合一故障处理工具</font>

_<font style="color:rgb(0, 0, 0);">此处因VisualVM未能成功安装而搁置</font>_

+ <font style="color:rgb(0, 0, 0);">p171 Java Mission Control - 可持续在线的监控工具（JMC和JFR）</font>
+ <font style="color:rgb(0, 0, 0);">p171 Oracle Java SE Support 和 Oracle Java Advanced & Suite</font>
+ <font style="color:rgb(0, 0, 0);">p174 飞行记录</font>

#### <font style="color:rgb(51, 51, 51);">4.4 HotSpot虚拟机插件及工具</font>
+ <font style="color:rgb(0, 0, 0);">p176 HSDIS - JIT生成代码反汇编</font>
+ <font style="color:rgb(0, 0, 0);">p179 JITWatch介绍</font>
+ <font style="color:rgb(0, 0, 0);">p179 把日志输出到logfile文件</font>

### **<font style="color:rgb(0, 0, 0);">第五章</font>**<font style="color:rgb(0, 0, 0);"> </font>**<font style="color:rgb(0, 0, 0);">调优案例分析与实战</font>**
#### <font style="color:rgb(51, 51, 51);">5.2 案例分析</font>
+ <font style="color:rgb(0, 0, 0);">p182 大内存硬件上的程序部署策略</font>
+ <font style="color:rgb(0, 0, 0);">p182 单体应用在较大内存硬件上的两种主要部署方式</font>
+ <font style="color:rgb(0, 0, 0);">p183 使用单个Java虚拟机实例管理大内存需要考虑的问题</font>
+ <font style="color:rgb(0, 0, 0);">p183 具备亲和性的集群</font>
+ <font style="color:rgb(0, 0, 0);">p183 使用逻辑集群部署程序需要考虑的问题</font>
+ <font style="color:rgb(0, 0, 0);">p184 集群间同步导致的内存溢出</font>
+ <font style="color:rgb(0, 0, 0);">p184 JBossCache</font>
+ <font style="color:rgb(0, 0, 0);">p185 堆外内存导致的溢出错误</font>
+ <font style="color:rgb(0, 0, 0);">p187 外部命令导致系统缓慢</font>
+ <font style="color:rgb(0, 0, 0);">p187 服务器虚拟机进程崩溃</font>
+ <font style="color:rgb(0, 0, 0);">p188 不恰当数据结构导致内存占用过大</font>
+ <font style="color:rgb(0, 0, 0);">p190 由安全点导致长时间停顿</font>
+ <font style="color:rgb(0, 0, 0);">p191 处理器时间和时钟时间</font>
+ <font style="color:rgb(0, 0, 0);">p192 可数循环和不可数循环</font>

#### <font style="color:rgb(51, 51, 51);">5.3 Eclipse运行速度调优</font>
<font style="color:rgb(0, 0, 0);">这里的可记录内容基本都在后面的章节有讲解，故不做整理</font>

<font style="color:rgb(0, 0, 0);">关注一下本章的5.3.x小节标题，这里调优Eclipse的过程可以视作一次简化的服务端调优过程，这里进行调优的顺序也有着参考价值</font>

### **<font style="color:rgb(0, 0, 0);">第六章</font>**<font style="color:rgb(0, 0, 0);"> </font>**<font style="color:rgb(0, 0, 0);">类文件结构</font>**
#### <font style="color:rgb(51, 51, 51);">6.2 无关性的基石</font>
+ <font style="color:rgb(0, 0, 0);">p213 不同平台的Java虚拟机和它们统一支持的存储格式字节码是平台无关性的基石</font>
+ <font style="color:rgb(0, 0, 0);">p213 Java虚拟机只与Class文件这种特定的二进制文件相关联</font>
+ <font style="color:rgb(0, 0, 0);">p213 字节码指令所能提供的语言描述能力要比Java语言更加强大</font>

#### <font style="color:rgb(51, 51, 51);">6.3 Class类文件的结构</font>
+ <font style="color:rgb(0, 0, 0);">p215 Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格紧凑排列</font>
+ <font style="color:rgb(0, 0, 0);">p215 Class文件伪结构的两种数据类型：无符号数和表</font>
+ <font style="color:rgb(0, 0, 0);">p215 Class文件中某一类型的“集合”</font>
+ <font style="color:rgb(0, 0, 0);">p215 Class文件格式表</font>
+ <font style="color:rgb(0, 0, 0);">p215 魔数与Class文件的版本</font>
+ <font style="color:rgb(0, 0, 0);">p216 Java的版本号</font>
+ <font style="color:rgb(0, 0, 0);">p218 常量池</font>
+ <font style="color:rgb(0, 0, 0);">p218 Class文件常量池中的字面量和符号引用</font>
+ <font style="color:rgb(0, 0, 0);">p219 动态连接</font>
+ <font style="color:rgb(0, 0, 0);">p219 常量池的17种项目类型</font>
+ <font style="color:rgb(0, 0, 0);">p220 UTF-8缩略编码</font>
+ <font style="color:rgb(0, 0, 0);">p221 javap工具-用于分析字节码文件</font>
+ <font style="color:rgb(0, 0, 0);">p223 常量池中的17种数据类型的结构总表</font>
+ <font style="color:rgb(0, 0, 0);">p224 类和接口的访问标志</font>
+ <font style="color:rgb(0, 0, 0);">p225 类索引、父类索引、接口索引集合</font>
+ <font style="color:rgb(0, 0, 0);">p226 字段表集合</font>
+ <font style="color:rgb(0, 0, 0);">p226 字段表结构</font>
+ <font style="color:rgb(0, 0, 0);">p227 字段访问标志</font>
+ <font style="color:rgb(0, 0, 0);">p227 方法和字段的描述符</font>
+ <font style="color:rgb(0, 0, 0);">p227 描述符标识字符含义</font>
+ <font style="color:rgb(0, 0, 0);">p229 方法表集合</font>
+ <font style="color:rgb(0, 0, 0);">p229 方法表结构</font>
+ <font style="color:rgb(0, 0, 0);">p229 方法访问标志</font>
+ <font style="color:rgb(0, 0, 0);">p230 类构造器</font><font style="color:rgb(0, 0, 0);">()方法和</font><font style="color:rgb(0, 0, 0);">()方法</font>
+ <font style="color:rgb(0, 0, 0);">p230 重载</font>
+ <font style="color:rgb(0, 0, 0);">p230 特征签名</font>
+ <font style="color:rgb(0, 0, 0);">p231 属性表集合</font>
+ <font style="color:rgb(0, 0, 0);">p231 虚拟机规范预定义的全部29种属性</font>
+ <font style="color:rgb(0, 0, 0);">p233 属性表结构（attribute）</font>
+ <font style="color:rgb(0, 0, 0);">p233 Code属性</font>
+ <font style="color:rgb(0, 0, 0);">p233 Code属性表结构</font>
+ <font style="color:rgb(0, 0, 0);">p234 变量槽</font>
+ <font style="color:rgb(0, 0, 0);">p234 字节码指令</font>
+ <font style="color:rgb(0, 0, 0);">p235 翻译字节码指令示例</font>
+ <font style="color:rgb(0, 0, 0);">p236 Java中this关键字功能的实现</font>
+ <font style="color:rgb(0, 0, 0);">p236 显示异常处理表（异常表）</font>
+ <font style="color:rgb(0, 0, 0);">p237 Java异常和finlly处理机制在字节码层面的实现</font>
+ <font style="color:rgb(0, 0, 0);">p239 Exceptions属性</font>
+ <font style="color:rgb(0, 0, 0);">p239 LineNumberTable属性</font>
+ <font style="color:rgb(0, 0, 0);">p240 LocalVariableTable及LocalVariableTypeTable属性</font>
+ <font style="color:rgb(0, 0, 0);">p241 SourceFIle及SourceDebugExtension属性</font>
+ <font style="color:rgb(0, 0, 0);">p241 ConstantValue属性</font>
+ <font style="color:rgb(0, 0, 0);">p242 对static变量和普通变量赋值的不同</font>
+ <font style="color:rgb(0, 0, 0);">p242 InnerClass属性</font>
+ <font style="color:rgb(0, 0, 0);">p243 Deprecated及Synthetic属性</font>
+ <font style="color:rgb(0, 0, 0);">p244 新的类型检查验证器</font>
+ <font style="color:rgb(0, 0, 0);">p244 栈映射帧</font>
+ <font style="color:rgb(0, 0, 0);">p245 Signature属性</font>
+ <font style="color:rgb(0, 0, 0);">p245 Java使用擦除法实现伪泛型的好处和坏处</font>
+ <font style="color:rgb(0, 0, 0);">p245 BootstrapMethods属性</font>
+ <font style="color:rgb(0, 0, 0);">p247 MethodParameters属性</font>
+ <font style="color:rgb(0, 0, 0);">p248 模块化相关属性</font>
+ <font style="color:rgb(0, 0, 0);">p248 Module属性</font>
+ <font style="color:rgb(0, 0, 0);">p249 exports属性</font>
+ <font style="color:rgb(0, 0, 0);">p249 ModulePackages属性</font>
+ <font style="color:rgb(0, 0, 0);">p249 ModuleMainClass属性</font>
+ <font style="color:rgb(0, 0, 0);">p250 运行时注解相关属性</font>
+ <font style="color:rgb(0, 0, 0);">p250 RuntimeVisibleAnnotations属性</font>
+ <font style="color:rgb(0, 0, 0);">p250 annotation属性</font>

#### <font style="color:rgb(51, 51, 51);">6.4 字节码指令简介</font>
+ <font style="color:rgb(0, 0, 0);">p251 操作码和操作数</font>
+ <font style="color:rgb(0, 0, 0);">p251 Java虚拟机操作码的长度仅为一个字节</font>
+ <font style="color:rgb(0, 0, 0);">p251 Java虚拟机解释器的伪代码模型</font>
+ <font style="color:rgb(0, 0, 0);">p251 字节码与数据类型</font>
+ <font style="color:rgb(0, 0, 0);">p252 操作码助记符</font>
+ <font style="color:rgb(0, 0, 0);">p252 Java虚拟机指令集所支持的数据类型</font>
+ <font style="color:rgb(0, 0, 0);">p253 加载和存储指令</font>
+ <font style="color:rgb(0, 0, 0);">p254 运算指令</font>
+ <font style="color:rgb(0, 0, 0);">p255 向最接近数舍入模式和向零舍入模式</font>
+ <font style="color:rgb(0, 0, 0);">p255 NaN值</font>
+ <font style="color:rgb(0, 0, 0);">p255 类型转换指令</font>
+ <font style="color:rgb(0, 0, 0);">p255 宽化类型转换和窄化类型转换</font>
+ <font style="color:rgb(0, 0, 0);">p256 对象创建与访问指令</font>
+ <font style="color:rgb(0, 0, 0);">p257 控制转移指令</font>
+ <font style="color:rgb(0, 0, 0);">P257 方法调用和返回指令</font>
+ <font style="color:rgb(0, 0, 0);">p258 异常处理指令</font>
+ <font style="color:rgb(0, 0, 0);">p258 同步指令</font>

#### <font style="color:rgb(51, 51, 51);">6.5 公有设计、私有实现</font>
+ <font style="color:rgb(0, 0, 0);">p260 虚拟机在后台如何处理Class文件是自由的，在外部看起来和规范一致即可</font>
+ <font style="color:rgb(0, 0, 0);">p260 虚拟机实现的两种主要方式</font>

### **<font style="color:rgb(0, 0, 0);">第七章</font>**<font style="color:rgb(0, 0, 0);"> </font>**<font style="color:rgb(0, 0, 0);">虚拟机类加载机制</font>**
+ <font style="color:rgb(0, 0, 0);">p262 虚拟机的类加载机制</font>

#### <font style="color:rgb(51, 51, 51);">7.2 类加载的时机</font>
+ <font style="color:rgb(0, 0, 0);">p263 类的生命周期（加载->验证->准备->解析->初始化->使用->卸载）</font>
+ <font style="color:rgb(0, 0, 0);">p263 有且只有六种情况导致类进行初始化</font>
+ <font style="color:rgb(0, 0, 0);">p264 主动引用和被动引用</font>

#### <font style="color:rgb(51, 51, 51);">7.3 类加载的过程</font>
+ <font style="color:rgb(0, 0, 0);">p267 加载</font>
+ <font style="color:rgb(0, 0, 0);">p267 Java虚拟机在类加载阶段需要完成的三件事情</font>
+ <font style="color:rgb(0, 0, 0);">p268 数组类创建过程中的规则</font>
+ <font style="color:rgb(0, 0, 0);">p268 验证</font>
+ <font style="color:rgb(0, 0, 0);">p268 验证的目的</font>
+ <font style="color:rgb(0, 0, 0);">p269 验证阶段的四个检验动作</font>
+ <font style="color:rgb(0, 0, 0);">p269 文件格式验证</font>
+ <font style="color:rgb(0, 0, 0);">p269 元数据验证</font>
+ <font style="color:rgb(0, 0, 0);">p270 字节码验证</font>
+ <font style="color:rgb(0, 0, 0);">p270 停机问题</font>
+ <font style="color:rgb(0, 0, 0);">p270 StackMapTable</font>
+ <font style="color:rgb(0, 0, 0);">p271 符号引用验证</font>
+ <font style="color:rgb(0, 0, 0);">p271 准备</font>
+ <font style="color:rgb(0, 0, 0);">p271 准备阶段</font>
+ <font style="color:rgb(0, 0, 0);">p272 JDK8之后，类变量随着对象一起存放在Java堆中</font>
+ <font style="color:rgb(0, 0, 0);">p272 基本数据类型的零值</font>
+ <font style="color:rgb(0, 0, 0);">p272 解析</font>
+ <font style="color:rgb(0, 0, 0);">p272 解析阶段</font>
+ <font style="color:rgb(0, 0, 0);">p272 符号引用</font>
+ <font style="color:rgb(0, 0, 0);">p273 直接引用</font>
+ <font style="color:rgb(0, 0, 0);">p273 17个需要先对符号引用进行解析的字节码指令</font>
+ <font style="color:rgb(0, 0, 0);">p273 多次解析</font>
+ <font style="color:rgb(0, 0, 0);">p274 解析动作针对的七类符号引用（八种常量类型）</font>
+ <font style="color:rgb(0, 0, 0);">p274 类或接口的解析</font>
+ <font style="color:rgb(0, 0, 0);">p274 类或接口解析的三大步骤</font>
+ <font style="color:rgb(0, 0, 0);">p274 一个类拥有另一个类的访问权限，需其中之一成立的三条规则</font>
+ <font style="color:rgb(0, 0, 0);">p275 字段解析</font>
+ <font style="color:rgb(0, 0, 0);">p276 方法解析</font>
+ <font style="color:rgb(0, 0, 0);">p276 接口方法解析</font>
+ <font style="color:rgb(0, 0, 0);">p277 初始化</font>
+ <font style="color:rgb(0, 0, 0);">p277 类的初始化阶段</font>
+ <font style="color:rgb(0, 0, 0);">p277</font><font style="color:rgb(0, 0, 0);"> </font><font style="color:rgb(0, 0, 0);">()方法</font>

#### <font style="color:rgb(51, 51, 51);">7.4 类加载器</font>
+ <font style="color:rgb(0, 0, 0);">p280 类加载器的定义</font>
+ <font style="color:rgb(0, 0, 0);">p280 类与类加载器</font>
+ <font style="color:rgb(0, 0, 0);">p280 每一个类加载器都拥有一个独立的类名称空间</font>
+ <font style="color:rgb(0, 0, 0);">p281 双亲委派模型</font>
+ <font style="color:rgb(0, 0, 0);">p281 Java虚拟机眼中的两种不同的类加载器</font>
+ <font style="color:rgb(0, 0, 0);">p282 三层类加载器、双亲委派的类加载架构</font>
+ <font style="color:rgb(0, 0, 0);">p282 启动类加载器</font>
+ <font style="color:rgb(0, 0, 0);">p282 扩展类加载器</font>
+ <font style="color:rgb(0, 0, 0);">p283 应用程序类加载器</font>
+ <font style="color:rgb(0, 0, 0);">p283 类加载器的双亲委派模型</font>
+ <font style="color:rgb(0, 0, 0);">p283 双亲委派模型的工作过程</font>
+ <font style="color:rgb(0, 0, 0);">p284 双亲委派模型的实现</font>
+ <font style="color:rgb(0, 0, 0);">p285 破坏双亲委派模型</font>
+ <font style="color:rgb(0, 0, 0);">p285 双亲委派模型的三次被破坏</font>
+ <font style="color:rgb(0, 0, 0);">p285 线程上下文类加载器</font>
+ <font style="color:rgb(0, 0, 0);">p286 OSGi是如何通过类加载器实现热部署的</font>

#### <font style="color:rgb(51, 51, 51);">7.5 Java模块化系统</font>
+ <font style="color:rgb(0, 0, 0);">p287 模块化的关键目标——可配置的封装隔离机制</font>
+ <font style="color:rgb(0, 0, 0);">p287 Java的模块定义所包含的内容</font>
+ <font style="color:rgb(0, 0, 0);">p288 模块的兼容性</font>
+ <font style="color:rgb(0, 0, 0);">p288 类路径和模块路径</font>
+ <font style="color:rgb(0, 0, 0);">p288 JAR文件和模块在类路径和模块路径的访问规则</font>
+ <font style="color:rgb(0, 0, 0);">p290 OSGi与JPMS交互</font>
+ <font style="color:rgb(0, 0, 0);">p290 模块化下的类加载器</font>
+ <font style="color:rgb(0, 0, 0);">p290 扩展类加载器被平台类加载器取代</font>
+ <font style="color:rgb(0, 0, 0);">p290 新版JDK取消jre目录</font>
+ <font style="color:rgb(0, 0, 0);">p291 平台类加载器和应用程序类加载器都不再派生自URLClassLoader</font>
+ <font style="color:rgb(0, 0, 0);">p291 jdk9以后三种类加载器各自负责的模块</font>

### **<font style="color:rgb(0, 0, 0);">第八章</font>**<font style="color:rgb(0, 0, 0);"> </font>**<font style="color:rgb(0, 0, 0);">虚拟机字节码执行引擎</font>**
+ <font style="color:rgb(0, 0, 0);">p293 虚拟机字节码执行引擎的概念模型</font>
+ <font style="color:rgb(0, 0, 0);">p293 虚拟机字节码执行引擎的输入输出</font>

#### <font style="color:rgb(51, 51, 51);">8.2 运行时栈帧结构</font>
+ <font style="color:rgb(0, 0, 0);">p294 栈帧的概念</font>
+ <font style="color:rgb(0, 0, 0);">p294 当前栈帧和当前方法</font>
+ <font style="color:rgb(0, 0, 0);">p294 虚拟机栈和栈帧的总体结构</font>
+ <font style="color:rgb(0, 0, 0);">p294 局部变量表</font>
+ <font style="color:rgb(0, 0, 0);">p294 局部变量表的概念</font>
+ <font style="color:rgb(0, 0, 0);">p294 变量槽</font>
+ <font style="color:rgb(0, 0, 0);">p295 Java中八种占用不超过32位存储空间的数据类型</font>
+ <font style="color:rgb(0, 0, 0);">p295 reference类型</font>
+ <font style="color:rgb(0, 0, 0);">p296 64位数据类型对变量槽的使用</font>
+ <font style="color:rgb(0, 0, 0);">p296 局部变量表的索引定位</font>
+ <font style="color:rgb(0, 0, 0);">p296 局部变量表的变量槽分配</font>
+ <font style="color:rgb(0, 0, 0);">p299 操作数栈</font>
+ <font style="color:rgb(0, 0, 0);">p299 栈帧的数据共享</font>
+ <font style="color:rgb(0, 0, 0);">p300 动态连接</font>
+ <font style="color:rgb(0, 0, 0);">p300 静态解析</font>
+ <font style="color:rgb(0, 0, 0);">p300 动态连接</font>
+ <font style="color:rgb(0, 0, 0);">p300 方法返回地址</font>
+ <font style="color:rgb(0, 0, 0);">p301 附加信息</font>
+ <font style="color:rgb(0, 0, 0);">p301 栈帧信息</font>

#### <font style="color:rgb(51, 51, 51);">8.3 方法调用</font>
+ <font style="color:rgb(0, 0, 0);">p301 解析</font>
+ <font style="color:rgb(0, 0, 0);">p302 解析的定义</font>
+ <font style="color:rgb(0, 0, 0);">p302 方法调用字节码指令</font>
+ <font style="color:rgb(0, 0, 0);">p302 非虚方法和虚方法</font>
+ <font style="color:rgb(0, 0, 0);">p303 分派</font>
+ <font style="color:rgb(0, 0, 0);">p303 静态分派</font>
+ <font style="color:rgb(0, 0, 0);">p305 静态类型（外观类型）和实际类型（运行时类型）</font>
+ <font style="color:rgb(0, 0, 0);">p305 重载时通过参数的静态类型而不是实际类型作为判断依据</font>
+ <font style="color:rgb(0, 0, 0);">p307 类型模糊</font>
+ <font style="color:rgb(0, 0, 0);">p308 动态分配</font>
+ <font style="color:rgb(0, 0, 0);">p310 invokevirtual指令的运行时解析过程</font>
+ <font style="color:rgb(0, 0, 0);">p311 Java语言中方法重写的本质</font>
+ <font style="color:rgb(0, 0, 0);">p312 单分派与多分派</font>
+ <font style="color:rgb(0, 0, 0);">p312 方法的宗量</font>
+ <font style="color:rgb(0, 0, 0);">p314 Java语言是一门静态多分派，动态单分派的语言</font>
+ <font style="color:rgb(0, 0, 0);">p314 虚拟机动态分派的实现</font>
+ <font style="color:rgb(0, 0, 0);">p314 虚方法表</font>
+ <font style="color:rgb(0, 0, 0);">p314 接口方法表</font>

#### <font style="color:rgb(51, 51, 51);">8.4 动态类型语言支持</font>
+ <font style="color:rgb(0, 0, 0);">p316 动态类型语言</font>
+ <font style="color:rgb(0, 0, 0);">p316 什么是动态类型语言</font>
+ <font style="color:rgb(0, 0, 0);">p316 运行时异常和连接时异常</font>
+ <font style="color:rgb(0, 0, 0);">p317 动态类型语言和静态类型语言的优缺点</font>
+ <font style="color:rgb(0, 0, 0);">p317 Java与动态类型</font>
+ <font style="color:rgb(0, 0, 0);">p318 java.lang.invoke包</font>
+ <font style="color:rgb(0, 0, 0);">p319 方法句柄</font>
+ <font style="color:rgb(0, 0, 0);">p319 方法句柄的基本用法</font>
+ <font style="color:rgb(0, 0, 0);">p320 MethodHandle和Reflection的区别</font>
+ <font style="color:rgb(0, 0, 0);">p321 invokedynamic指令</font>
+ <font style="color:rgb(0, 0, 0);">p321 动态调用点</font>
+ <font style="color:rgb(0, 0, 0);">p321 CONSTANT_InvokeDynamic_Info常量</font>
+ <font style="color:rgb(0, 0, 0);">p324 实战:掌控方法分派规则</font>

#### <font style="color:rgb(51, 51, 51);">8.5 基于栈的字节码解释执行引擎</font>
+ <font style="color:rgb(0, 0, 0);">p327 解释执行</font>
+ <font style="color:rgb(0, 0, 0);">p327 编译过程</font>
+ <font style="color:rgb(0, 0, 0);">p328 基于栈的指令集与基于寄存器的指令集</font>
+ <font style="color:rgb(0, 0, 0);">p329 两种指令集的优缺点</font>
+ <font style="color:rgb(0, 0, 0);">p329 基于栈的解释器执行过程</font>

### **<font style="color:rgb(0, 0, 0);">第九章</font>**<font style="color:rgb(0, 0, 0);"> </font>**<font style="color:rgb(0, 0, 0);">类加载及执行子系统的案例与实战</font>**
#### <font style="color:rgb(51, 51, 51);">9.2 案例分析</font>
+ <font style="color:rgb(0, 0, 0);">p335 Tomcat：正统的类加载器架构</font>
+ <font style="color:rgb(0, 0, 0);">p336 功能健全的web服务器需要解决的问题</font>
+ <font style="color:rgb(0, 0, 0);">p337 Tomcat服务器的类加载架构</font>
+ <font style="color:rgb(0, 0, 0);">p338 OSGi：灵活的类加载器架构</font>
+ <font style="color:rgb(0, 0, 0);">p339 OSGi（后续有详细讲解）</font>
+ <font style="color:rgb(0, 0, 0);">p339 引入OSGi的理由</font>
+ <font style="color:rgb(0, 0, 0);">p341 字节码生成技术与动态代理的实现</font>
+ <font style="color:rgb(0, 0, 0);">p342 动态代理的简单示例</font>
+ <font style="color:rgb(0, 0, 0);">p345 Backport工具：Java的时光机器</font>
+ <font style="color:rgb(0, 0, 0);">p345 Retrotranslator和Retrolambd</font>

#### <font style="color:rgb(51, 51, 51);">9.3 实战：自己动手实现远程执行功能</font>
**<font style="color:rgb(0, 0, 0);">尚未完成</font>**

### **<font style="color:rgb(0, 0, 0);">第十章</font>**<font style="color:rgb(0, 0, 0);"> </font>**<font style="color:rgb(0, 0, 0);">前端编译与优化</font>**
#### <font style="color:rgb(51, 51, 51);">10.1 概述</font>
+ <font style="color:rgb(0, 0, 0);">p358 Java中的三种编译器</font>

#### <font style="color:rgb(51, 51, 51);">10.2 Javac编译器</font>
+ <font style="color:rgb(0, 0, 0);">p359 Javac的源码与调试</font>
+ <font style="color:rgb(0, 0, 0);">p361 Javac编译的一个准备过程和三个处理过程</font>
+ <font style="color:rgb(0, 0, 0);">p362 解析与填充符号表</font>
+ <font style="color:rgb(0, 0, 0);">p362 词法、语法分析</font>
+ <font style="color:rgb(0, 0, 0);">p362 词法分析</font>
+ <font style="color:rgb(0, 0, 0);">p362 标记</font>
+ <font style="color:rgb(0, 0, 0);">p362 语法分析</font>
+ <font style="color:rgb(0, 0, 0);">p363 填充符号表</font>
+ <font style="color:rgb(0, 0, 0);">p363 符号表</font>
+ <font style="color:rgb(0, 0, 0);">p363 注解处理器</font>
+ <font style="color:rgb(0, 0, 0);">p364 轮次</font>
+ <font style="color:rgb(0, 0, 0);">p364 语义分析与字节码生成</font>
+ <font style="color:rgb(0, 0, 0);">p364 语义分析</font>
+ <font style="color:rgb(0, 0, 0);">p365 标注检查</font>
+ <font style="color:rgb(0, 0, 0);">p365 常量折叠</font>
+ <font style="color:rgb(0, 0, 0);">p365 数据与控制流分析</font>
+ <font style="color:rgb(0, 0, 0);">p366 解语法糖</font>
+ <font style="color:rgb(0, 0, 0);">p366 语法糖</font>
+ <font style="color:rgb(0, 0, 0);">p367 字节码生成</font>

#### <font style="color:rgb(51, 51, 51);">10.3 Java语法糖的味道</font>
+ <font style="color:rgb(0, 0, 0);">p367 泛型</font>
+ <font style="color:rgb(0, 0, 0);">p367 泛型的本质</font>
+ <font style="color:rgb(0, 0, 0);">p368 Java与C#的泛型</font>
+ <font style="color:rgb(0, 0, 0);">p368 类型擦除</font>
+ <font style="color:rgb(0, 0, 0);">p369 泛型的历史背景</font>
+ <font style="color:rgb(0, 0, 0);">p369 二进制向后兼容性</font>
+ <font style="color:rgb(0, 0, 0);">p370 数组的协变</font>
+ <font style="color:rgb(0, 0, 0);">p371 类型擦除</font>
+ <font style="color:rgb(0, 0, 0);">p371 裸类型</font>
+ <font style="color:rgb(0, 0, 0);">p374 Signature</font>
+ <font style="color:rgb(0, 0, 0);">p374 值类型与未来的泛型</font>
+ <font style="color:rgb(0, 0, 0);">p374 Valhalla</font>
+ <font style="color:rgb(0, 0, 0);">p375 自动装箱、拆箱与遍历循环</font>
+ <font style="color:rgb(0, 0, 0);">p377 条件编译</font>

#### <font style="color:rgb(51, 51, 51);">10.4 实战：插入式注解处理器</font>
+ <font style="color:rgb(0, 0, 0);">p379 代码实现</font>
+ <font style="color:rgb(0, 0, 0);">p379 注解处理器必须继承的抽象类AbstractProcessor</font>
+ <font style="color:rgb(0, 0, 0);">p380 @SupportedAnnotationTypes注解和@SupportedSourceVersion注解</font>
+ <font style="color:rgb(0, 0, 0);">p385 运行与测试</font>
+ <font style="color:rgb(0, 0, 0);">p385 使用“-processor”参数来执行编译时需要附带的注解处理器</font>
+ <font style="color:rgb(0, 0, 0);">p385 使用 -XprintRounds 和 -XprintProcessorInfor 参数来查看注解处理器运作的详细信息</font>

### **<font style="color:rgb(0, 0, 0);">第十一章</font>**<font style="color:rgb(0, 0, 0);"> </font>**<font style="color:rgb(0, 0, 0);">后端编译与优化</font>**
#### <font style="color:rgb(51, 51, 51);">11.2 即时编译器</font>
+ <font style="color:rgb(0, 0, 0);">p389 热点代码</font>
+ <font style="color:rgb(0, 0, 0);">p389 即时编译器</font>
+ <font style="color:rgb(0, 0, 0);">p389 解释器与编译器</font>
+ <font style="color:rgb(0, 0, 0);">p389 解释器与编译器各自的优势</font>
+ <font style="color:rgb(0, 0, 0);">p389 逃生门</font>
+ <font style="color:rgb(0, 0, 0);">p390 罕见陷阱</font>
+ <font style="color:rgb(0, 0, 0);">p390 逆优化</font>
+ <font style="color:rgb(0, 0, 0);">p390 客户端编译器（Ｃ１编译器）和服务端编译器（Ｃ２编译器）</font>
+ <font style="color:rgb(0, 0, 0);">p390 混合模式、解释模式、编译模式</font>
+ <font style="color:rgb(0, 0, 0);">p391 分层编译</font>
+ <font style="color:rgb(0, 0, 0);">p392 编译对象与触发条件</font>
+ <font style="color:rgb(0, 0, 0);">p392 两类热点代码（被多次调用方法和被多次执行的循环体）</font>
+ <font style="color:rgb(0, 0, 0);">p392 栈上替换</font>
+ <font style="color:rgb(0, 0, 0);">p392 热点探测</font>
+ <font style="color:rgb(0, 0, 0);">p393 两种主流的热点探测判定方式（基于采样的热点探测和基于计数器的热点探测）</font>
+ <font style="color:rgb(0, 0, 0);">p393 方法调用计数器</font>
+ <font style="color:rgb(0, 0, 0);">p393 方法调用计数器的衰减</font>
+ <font style="color:rgb(0, 0, 0);">p393 方法统计的半衰周期</font>
+ <font style="color:rgb(0, 0, 0);">p394 回边计数器</font>
+ <font style="color:rgb(0, 0, 0);">p397 编译过程</font>
+ <font style="color:rgb(0, 0, 0);">p397 客户端编译器</font>
+ <font style="color:rgb(0, 0, 0);">p398 服务端编译器</font>

#### <font style="color:rgb(51, 51, 51);">11.3 提前编译器</font>
+ <font style="color:rgb(0, 0, 0);">P405 提前编译的优劣得失</font>
+ <font style="color:rgb(0, 0, 0);">p405 提前编译产品和对其研究的两个分支</font>
+ <font style="color:rgb(0, 0, 0);">p407 三种即时编译器相对提前编译器的优势（性能分析制导优化、激进预测性优化、链接时优化）</font>

#### <font style="color:rgb(51, 51, 51);">11.4 编译器优化技术</font>
+ <font style="color:rgb(0, 0, 0);">p411 优化技术概览</font>
+ <font style="color:rgb(0, 0, 0);">p412 即时编译器优化技术一览</font>
+ <font style="color:rgb(0, 0, 0);">p414 方法内联的两个主要目的（去除方法调用的成本、为其他优化建立基础）</font>
+ <font style="color:rgb(0, 0, 0);">p414 冗余访问清除</font>
+ <font style="color:rgb(0, 0, 0);">p415 复写传播</font>
+ <font style="color:rgb(0, 0, 0);">p415 无用代码消除</font>
+ <font style="color:rgb(0, 0, 0);">p415 方法内联</font>
+ <font style="color:rgb(0, 0, 0);">p416 Java中虚方法无法内联的原因</font>
+ <font style="color:rgb(0, 0, 0);">p417 类型继承关系分析</font>
+ <font style="color:rgb(0, 0, 0);">p417 守护内联</font>
+ <font style="color:rgb(0, 0, 0);">p417 内联缓存（单态内联缓存和超多态内联缓存）</font>
+ <font style="color:rgb(0, 0, 0);">p417 逃逸分析</font>
+ <font style="color:rgb(0, 0, 0);">p418 逃逸分析的基本原理</font>
+ <font style="color:rgb(0, 0, 0);">p418 栈上分配</font>
+ <font style="color:rgb(0, 0, 0);">p418 标量替换</font>
+ <font style="color:rgb(0, 0, 0);">p418 标量和聚合量</font>
+ <font style="color:rgb(0, 0, 0);">p418 同步消除</font>
+ <font style="color:rgb(0, 0, 0);">p420 公共子表达式消除</font>
+ <font style="color:rgb(0, 0, 0);">p420 公共子表达式</font>
+ <font style="color:rgb(0, 0, 0);">p421 代数化简</font>
+ <font style="color:rgb(0, 0, 0);">p421 数组边界检查消除</font>
+ <font style="color:rgb(0, 0, 0);">p421 数组边界检查消除的概念和场景</font>
+ <font style="color:rgb(0, 0, 0);">p422 隐式异常处理</font>

### 第十二章 java内存模型与线程
+ MESI，共享内存多核系统面对的问题
+ 指令重排序问题
+ 线程自己的工作内存，线程和变量之间遵循指令。只对副本进行操作，操作完毕后刷回主内存。
+ 内存间交互工作
+ 规定了一些指令，read，load，lock，unlock等。并且这些指令之间有严格的先后关系或者成对关系。
+ 对于volatile变量的特殊规则
    - 如果操作是原子的，那么volatile变量是安全的。
    - 单条字节码（尽管只有一条字节码）但是仍然不能说它是原子的，可能翻译成机器码之后就不是原子的。
    - 禁止指令重排序。
    - 使用lock指令，通知其他处理器缓存失效。但是为何说它能够禁止指令重排序呢？
    - 内存屏障
+ long、double的非原子性协定。
+ 原子性、可见性、有序性
+ 先行发生原则happens-before
+ java与线程

#### 12.4线程的实现
+ java线程的实现
+ 早期java也是使用用户线程的，但是后面因为各种各样的原因使用了系统线程。
+ 状态转换
+ 虽然tomcat8.5之后已经完全放弃了bio，使用了nio，但是nio只在接收信息发送信息的时候使用，在线程执行时还是单线程执行的，所以threadlocal还是可用，不会出现上半部分是一个线程，遇到事件后下半部分不是该线程了。

### 第十三章 线程安全与锁优化
+ 虽然synchronized是可重入的，但是他有一些缺点。
    - 忙等待，进入等待队列的线程会一直等待。
    - 非公平的锁。
    - 不能绑定条件，比较单一。
+ 为了解决这几个问题，提出了reentrantlock。虽然后者默认也是非公平锁。
+ 后面再提到了对象头，偏向锁，轻量级锁，重量级锁的实现方式以及各种情况的变化。

再后来就是展望了，这里更粗看。



1.16，看完本书。纵观本书，在经历过一些源码和实践之后，已经不再感到绝对的晦涩难懂。对各个子系统的实现方式，必要性都有了一个了解。从java内存区域，到垃圾回收，到jdk工具，到class类文件结构，到类加载子系统，到字节码执行引擎，到执行子系统，到前端编译，后端优化，到线程和锁。收获颇丰。

